/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/bottleneck/lib/Batcher.js":
/*!************************************************!*\
  !*** ./node_modules/bottleneck/lib/Batcher.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar Batcher, Events, parser;\r\nparser = __webpack_require__(/*! ./parser */ \"./node_modules/bottleneck/lib/parser.js\");\r\nEvents = __webpack_require__(/*! ./Events */ \"./node_modules/bottleneck/lib/Events.js\");\r\n\r\nBatcher = function () {\r\n  class Batcher {\r\n    constructor(options = {}) {\r\n      this.options = options;\r\n      parser.load(this.options, this.defaults, this);\r\n      this.Events = new Events(this);\r\n      this._arr = [];\r\n\r\n      this._resetPromise();\r\n\r\n      this._lastFlush = Date.now();\r\n    }\r\n\r\n    _resetPromise() {\r\n      return this._promise = new this.Promise((res, rej) => {\r\n        return this._resolve = res;\r\n      });\r\n    }\r\n\r\n    _flush() {\r\n      clearTimeout(this._timeout);\r\n      this._lastFlush = Date.now();\r\n\r\n      this._resolve();\r\n\r\n      this.Events.trigger(\"batch\", this._arr);\r\n      this._arr = [];\r\n      return this._resetPromise();\r\n    }\r\n\r\n    add(data) {\r\n      var ret;\r\n\r\n      this._arr.push(data);\r\n\r\n      ret = this._promise;\r\n\r\n      if (this._arr.length === this.maxSize) {\r\n        this._flush();\r\n      } else if (this.maxTime != null && this._arr.length === 1) {\r\n        this._timeout = setTimeout(() => {\r\n          return this._flush();\r\n        }, this.maxTime);\r\n      }\r\n\r\n      return ret;\r\n    }\r\n\r\n  }\r\n\r\n  ;\r\n  Batcher.prototype.defaults = {\r\n    maxTime: null,\r\n    maxSize: null,\r\n    Promise: Promise\r\n  };\r\n  return Batcher;\r\n}.call(void 0);\r\n\r\nmodule.exports = Batcher;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/Batcher.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/Bottleneck.js":
/*!***************************************************!*\
  !*** ./node_modules/bottleneck/lib/Bottleneck.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\r\n\r\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\r\n\r\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\r\n\r\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\r\n\r\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\r\n\r\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\r\n\r\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\r\n\r\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\r\n\r\nvar Bottleneck,\r\n    DEFAULT_PRIORITY,\r\n    Events,\r\n    Job,\r\n    LocalDatastore,\r\n    NUM_PRIORITIES,\r\n    Queues,\r\n    RedisDatastore,\r\n    States,\r\n    Sync,\r\n    parser,\r\n    splice = [].splice;\r\nNUM_PRIORITIES = 10;\r\nDEFAULT_PRIORITY = 5;\r\nparser = __webpack_require__(/*! ./parser */ \"./node_modules/bottleneck/lib/parser.js\");\r\nQueues = __webpack_require__(/*! ./Queues */ \"./node_modules/bottleneck/lib/Queues.js\");\r\nJob = __webpack_require__(/*! ./Job */ \"./node_modules/bottleneck/lib/Job.js\");\r\nLocalDatastore = __webpack_require__(/*! ./LocalDatastore */ \"./node_modules/bottleneck/lib/LocalDatastore.js\");\r\nRedisDatastore = __webpack_require__(/*! ./RedisDatastore */ \"./node_modules/bottleneck/lib/RedisDatastore.js\");\r\nEvents = __webpack_require__(/*! ./Events */ \"./node_modules/bottleneck/lib/Events.js\");\r\nStates = __webpack_require__(/*! ./States */ \"./node_modules/bottleneck/lib/States.js\");\r\nSync = __webpack_require__(/*! ./Sync */ \"./node_modules/bottleneck/lib/Sync.js\");\r\n\r\nBottleneck = function () {\r\n  class Bottleneck {\r\n    constructor(options = {}, ...invalid) {\r\n      var storeInstanceOptions, storeOptions;\r\n      this._addToQueue = this._addToQueue.bind(this);\r\n\r\n      this._validateOptions(options, invalid);\r\n\r\n      parser.load(options, this.instanceDefaults, this);\r\n      this._queues = new Queues(NUM_PRIORITIES);\r\n      this._scheduled = {};\r\n      this._states = new States([\"RECEIVED\", \"QUEUED\", \"RUNNING\", \"EXECUTING\"].concat(this.trackDoneStatus ? [\"DONE\"] : []));\r\n      this._limiter = null;\r\n      this.Events = new Events(this);\r\n      this._submitLock = new Sync(\"submit\", this.Promise);\r\n      this._registerLock = new Sync(\"register\", this.Promise);\r\n      storeOptions = parser.load(options, this.storeDefaults, {});\r\n\r\n      this._store = function () {\r\n        if (this.datastore === \"redis\" || this.datastore === \"ioredis\" || this.connection != null) {\r\n          storeInstanceOptions = parser.load(options, this.redisStoreDefaults, {});\r\n          return new RedisDatastore(this, storeOptions, storeInstanceOptions);\r\n        } else if (this.datastore === \"local\") {\r\n          storeInstanceOptions = parser.load(options, this.localStoreDefaults, {});\r\n          return new LocalDatastore(this, storeOptions, storeInstanceOptions);\r\n        } else {\r\n          throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);\r\n        }\r\n      }.call(this);\r\n\r\n      this._queues.on(\"leftzero\", () => {\r\n        var ref;\r\n        return (ref = this._store.heartbeat) != null ? typeof ref.ref === \"function\" ? ref.ref() : void 0 : void 0;\r\n      });\r\n\r\n      this._queues.on(\"zero\", () => {\r\n        var ref;\r\n        return (ref = this._store.heartbeat) != null ? typeof ref.unref === \"function\" ? ref.unref() : void 0 : void 0;\r\n      });\r\n    }\r\n\r\n    _validateOptions(options, invalid) {\r\n      if (!(options != null && typeof options === \"object\" && invalid.length === 0)) {\r\n        throw new Bottleneck.prototype.BottleneckError(\"Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.\");\r\n      }\r\n    }\r\n\r\n    ready() {\r\n      return this._store.ready;\r\n    }\r\n\r\n    clients() {\r\n      return this._store.clients;\r\n    }\r\n\r\n    channel() {\r\n      return `b_${this.id}`;\r\n    }\r\n\r\n    channel_client() {\r\n      return `b_${this.id}_${this._store.clientId}`;\r\n    }\r\n\r\n    publish(message) {\r\n      return this._store.__publish__(message);\r\n    }\r\n\r\n    disconnect(flush = true) {\r\n      return this._store.__disconnect__(flush);\r\n    }\r\n\r\n    chain(_limiter) {\r\n      this._limiter = _limiter;\r\n      return this;\r\n    }\r\n\r\n    queued(priority) {\r\n      return this._queues.queued(priority);\r\n    }\r\n\r\n    clusterQueued() {\r\n      return this._store.__queued__();\r\n    }\r\n\r\n    empty() {\r\n      return this.queued() === 0 && this._submitLock.isEmpty();\r\n    }\r\n\r\n    running() {\r\n      return this._store.__running__();\r\n    }\r\n\r\n    done() {\r\n      return this._store.__done__();\r\n    }\r\n\r\n    jobStatus(id) {\r\n      return this._states.jobStatus(id);\r\n    }\r\n\r\n    jobs(status) {\r\n      return this._states.statusJobs(status);\r\n    }\r\n\r\n    counts() {\r\n      return this._states.statusCounts();\r\n    }\r\n\r\n    _randomIndex() {\r\n      return Math.random().toString(36).slice(2);\r\n    }\r\n\r\n    check(weight = 1) {\r\n      return this._store.__check__(weight);\r\n    }\r\n\r\n    _clearGlobalState(index) {\r\n      if (this._scheduled[index] != null) {\r\n        clearTimeout(this._scheduled[index].expiration);\r\n        delete this._scheduled[index];\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    _free(index, job, options, eventInfo) {\r\n      var _this = this;\r\n\r\n      return _asyncToGenerator(function* () {\r\n        var e, running;\r\n\r\n        try {\r\n          var _ref = yield _this._store.__free__(index, options.weight);\r\n\r\n          running = _ref.running;\r\n\r\n          _this.Events.trigger(\"debug\", `Freed ${options.id}`, eventInfo);\r\n\r\n          if (running === 0 && _this.empty()) {\r\n            return _this.Events.trigger(\"idle\");\r\n          }\r\n        } catch (error1) {\r\n          e = error1;\r\n          return _this.Events.trigger(\"error\", e);\r\n        }\r\n      })();\r\n    }\r\n\r\n    _run(index, job, wait) {\r\n      var clearGlobalState, free, run;\r\n      job.doRun();\r\n      clearGlobalState = this._clearGlobalState.bind(this, index);\r\n      run = this._run.bind(this, index, job);\r\n      free = this._free.bind(this, index, job);\r\n      return this._scheduled[index] = {\r\n        timeout: setTimeout(() => {\r\n          return job.doExecute(this._limiter, clearGlobalState, run, free);\r\n        }, wait),\r\n        expiration: job.options.expiration != null ? setTimeout(function () {\r\n          return job.doExpire(clearGlobalState, run, free);\r\n        }, wait + job.options.expiration) : void 0,\r\n        job: job\r\n      };\r\n    }\r\n\r\n    _drainOne(capacity) {\r\n      return this._registerLock.schedule(() => {\r\n        var args, index, next, options, queue;\r\n\r\n        if (this.queued() === 0) {\r\n          return this.Promise.resolve(null);\r\n        }\r\n\r\n        queue = this._queues.getFirst();\r\n\r\n        var _next2 = next = queue.first();\r\n\r\n        options = _next2.options;\r\n        args = _next2.args;\r\n\r\n        if (capacity != null && options.weight > capacity) {\r\n          return this.Promise.resolve(null);\r\n        }\r\n\r\n        this.Events.trigger(\"debug\", `Draining ${options.id}`, {\r\n          args,\r\n          options\r\n        });\r\n        index = this._randomIndex();\r\n        return this._store.__register__(index, options.weight, options.expiration).then(({\r\n          success,\r\n          wait,\r\n          reservoir\r\n        }) => {\r\n          var empty;\r\n          this.Events.trigger(\"debug\", `Drained ${options.id}`, {\r\n            success,\r\n            args,\r\n            options\r\n          });\r\n\r\n          if (success) {\r\n            queue.shift();\r\n            empty = this.empty();\r\n\r\n            if (empty) {\r\n              this.Events.trigger(\"empty\");\r\n            }\r\n\r\n            if (reservoir === 0) {\r\n              this.Events.trigger(\"depleted\", empty);\r\n            }\r\n\r\n            this._run(index, next, wait);\r\n\r\n            return this.Promise.resolve(options.weight);\r\n          } else {\r\n            return this.Promise.resolve(null);\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    _drainAll(capacity, total = 0) {\r\n      return this._drainOne(capacity).then(drained => {\r\n        var newCapacity;\r\n\r\n        if (drained != null) {\r\n          newCapacity = capacity != null ? capacity - drained : capacity;\r\n          return this._drainAll(newCapacity, total + drained);\r\n        } else {\r\n          return this.Promise.resolve(total);\r\n        }\r\n      }).catch(e => {\r\n        return this.Events.trigger(\"error\", e);\r\n      });\r\n    }\r\n\r\n    _dropAllQueued(message) {\r\n      return this._queues.shiftAll(function (job) {\r\n        return job.doDrop({\r\n          message\r\n        });\r\n      });\r\n    }\r\n\r\n    stop(options = {}) {\r\n      var done, waitForExecuting;\r\n      options = parser.load(options, this.stopDefaults);\r\n\r\n      waitForExecuting = at => {\r\n        var finished;\r\n\r\n        finished = () => {\r\n          var counts;\r\n          counts = this._states.counts;\r\n          return counts[0] + counts[1] + counts[2] + counts[3] === at;\r\n        };\r\n\r\n        return new this.Promise((resolve, reject) => {\r\n          if (finished()) {\r\n            return resolve();\r\n          } else {\r\n            return this.on(\"done\", () => {\r\n              if (finished()) {\r\n                this.removeAllListeners(\"done\");\r\n                return resolve();\r\n              }\r\n            });\r\n          }\r\n        });\r\n      };\r\n\r\n      done = options.dropWaitingJobs ? (this._run = function (index, next) {\r\n        return next.doDrop({\r\n          message: options.dropErrorMessage\r\n        });\r\n      }, this._drainOne = () => {\r\n        return this.Promise.resolve(null);\r\n      }, this._registerLock.schedule(() => {\r\n        return this._submitLock.schedule(() => {\r\n          var k, ref, v;\r\n          ref = this._scheduled;\r\n\r\n          for (k in ref) {\r\n            v = ref[k];\r\n\r\n            if (this.jobStatus(v.job.options.id) === \"RUNNING\") {\r\n              clearTimeout(v.timeout);\r\n              clearTimeout(v.expiration);\r\n              v.job.doDrop({\r\n                message: options.dropErrorMessage\r\n              });\r\n            }\r\n          }\r\n\r\n          this._dropAllQueued(options.dropErrorMessage);\r\n\r\n          return waitForExecuting(0);\r\n        });\r\n      })) : this.schedule({\r\n        priority: NUM_PRIORITIES - 1,\r\n        weight: 0\r\n      }, () => {\r\n        return waitForExecuting(1);\r\n      });\r\n\r\n      this._receive = function (job) {\r\n        return job._reject(new Bottleneck.prototype.BottleneckError(options.enqueueErrorMessage));\r\n      };\r\n\r\n      this.stop = () => {\r\n        return this.Promise.reject(new Bottleneck.prototype.BottleneckError(\"stop() has already been called\"));\r\n      };\r\n\r\n      return done;\r\n    }\r\n\r\n    _addToQueue(job) {\r\n      var _this2 = this;\r\n\r\n      return _asyncToGenerator(function* () {\r\n        var args, blocked, error, options, reachedHWM, shifted, strategy;\r\n        args = job.args;\r\n        options = job.options;\r\n\r\n        try {\r\n          var _ref2 = yield _this2._store.__submit__(_this2.queued(), options.weight);\r\n\r\n          reachedHWM = _ref2.reachedHWM;\r\n          blocked = _ref2.blocked;\r\n          strategy = _ref2.strategy;\r\n        } catch (error1) {\r\n          error = error1;\r\n\r\n          _this2.Events.trigger(\"debug\", `Could not queue ${options.id}`, {\r\n            args,\r\n            options,\r\n            error\r\n          });\r\n\r\n          job.doDrop({\r\n            error\r\n          });\r\n          return false;\r\n        }\r\n\r\n        if (blocked) {\r\n          job.doDrop();\r\n          return true;\r\n        } else if (reachedHWM) {\r\n          shifted = strategy === Bottleneck.prototype.strategy.LEAK ? _this2._queues.shiftLastFrom(options.priority) : strategy === Bottleneck.prototype.strategy.OVERFLOW_PRIORITY ? _this2._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck.prototype.strategy.OVERFLOW ? job : void 0;\r\n\r\n          if (shifted != null) {\r\n            shifted.doDrop();\r\n          }\r\n\r\n          if (shifted == null || strategy === Bottleneck.prototype.strategy.OVERFLOW) {\r\n            if (shifted == null) {\r\n              job.doDrop();\r\n            }\r\n\r\n            return reachedHWM;\r\n          }\r\n        }\r\n\r\n        job.doQueue(reachedHWM, blocked);\r\n\r\n        _this2._queues.push(job);\r\n\r\n        yield _this2._drainAll();\r\n        return reachedHWM;\r\n      })();\r\n    }\r\n\r\n    _receive(job) {\r\n      if (this._states.jobStatus(job.options.id) != null) {\r\n        job._reject(new Bottleneck.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));\r\n\r\n        return false;\r\n      } else {\r\n        job.doReceive();\r\n        return this._submitLock.schedule(this._addToQueue, job);\r\n      }\r\n    }\r\n\r\n    submit(...args) {\r\n      var cb, fn, job, options, ref, ref1, task;\r\n\r\n      if (typeof args[0] === \"function\") {\r\n        var _ref3, _ref4, _splice$call, _splice$call2;\r\n\r\n        ref = args, (_ref3 = ref, _ref4 = _toArray(_ref3), fn = _ref4[0], args = _ref4.slice(1), _ref3), (_splice$call = splice.call(args, -1), _splice$call2 = _slicedToArray(_splice$call, 1), cb = _splice$call2[0], _splice$call);\r\n        options = parser.load({}, this.jobDefaults);\r\n      } else {\r\n        var _ref5, _ref6, _splice$call3, _splice$call4;\r\n\r\n        ref1 = args, (_ref5 = ref1, _ref6 = _toArray(_ref5), options = _ref6[0], fn = _ref6[1], args = _ref6.slice(2), _ref5), (_splice$call3 = splice.call(args, -1), _splice$call4 = _slicedToArray(_splice$call3, 1), cb = _splice$call4[0], _splice$call3);\r\n        options = parser.load(options, this.jobDefaults);\r\n      }\r\n\r\n      task = (...args) => {\r\n        return new this.Promise(function (resolve, reject) {\r\n          return fn(...args, function (...args) {\r\n            return (args[0] != null ? reject : resolve)(args);\r\n          });\r\n        });\r\n      };\r\n\r\n      job = new Job(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\r\n      job.promise.then(function (args) {\r\n        return typeof cb === \"function\" ? cb(...args) : void 0;\r\n      }).catch(function (args) {\r\n        if (Array.isArray(args)) {\r\n          return typeof cb === \"function\" ? cb(...args) : void 0;\r\n        } else {\r\n          return typeof cb === \"function\" ? cb(args) : void 0;\r\n        }\r\n      });\r\n      return this._receive(job);\r\n    }\r\n\r\n    schedule(...args) {\r\n      var job, options, task;\r\n\r\n      if (typeof args[0] === \"function\") {\r\n        var _args = args;\r\n\r\n        var _args2 = _toArray(_args);\r\n\r\n        task = _args2[0];\r\n        args = _args2.slice(1);\r\n        options = {};\r\n      } else {\r\n        var _args3 = args;\r\n\r\n        var _args4 = _toArray(_args3);\r\n\r\n        options = _args4[0];\r\n        task = _args4[1];\r\n        args = _args4.slice(2);\r\n      }\r\n\r\n      job = new Job(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);\r\n\r\n      this._receive(job);\r\n\r\n      return job.promise;\r\n    }\r\n\r\n    wrap(fn) {\r\n      var schedule, wrapped;\r\n      schedule = this.schedule.bind(this);\r\n\r\n      wrapped = function wrapped(...args) {\r\n        return schedule(fn.bind(this), ...args);\r\n      };\r\n\r\n      wrapped.withOptions = function (options, ...args) {\r\n        return schedule(options, fn, ...args);\r\n      };\r\n\r\n      return wrapped;\r\n    }\r\n\r\n    updateSettings(options = {}) {\r\n      var _this3 = this;\r\n\r\n      return _asyncToGenerator(function* () {\r\n        yield _this3._store.__updateSettings__(parser.overwrite(options, _this3.storeDefaults));\r\n        parser.overwrite(options, _this3.instanceDefaults, _this3);\r\n        return _this3;\r\n      })();\r\n    }\r\n\r\n    currentReservoir() {\r\n      return this._store.__currentReservoir__();\r\n    }\r\n\r\n    incrementReservoir(incr = 0) {\r\n      return this._store.__incrementReservoir__(incr);\r\n    }\r\n\r\n  }\r\n\r\n  ;\r\n  Bottleneck.default = Bottleneck;\r\n  Bottleneck.Events = Events;\r\n  Bottleneck.version = Bottleneck.prototype.version = (__webpack_require__(/*! ./version.json */ \"./node_modules/bottleneck/lib/version.json\").version);\r\n  Bottleneck.strategy = Bottleneck.prototype.strategy = {\r\n    LEAK: 1,\r\n    OVERFLOW: 2,\r\n    OVERFLOW_PRIORITY: 4,\r\n    BLOCK: 3\r\n  };\r\n  Bottleneck.BottleneckError = Bottleneck.prototype.BottleneckError = __webpack_require__(/*! ./BottleneckError */ \"./node_modules/bottleneck/lib/BottleneckError.js\");\r\n  Bottleneck.Group = Bottleneck.prototype.Group = __webpack_require__(/*! ./Group */ \"./node_modules/bottleneck/lib/Group.js\");\r\n  Bottleneck.RedisConnection = Bottleneck.prototype.RedisConnection = __webpack_require__(/*! ./RedisConnection */ \"./node_modules/bottleneck/lib/RedisConnection.js\");\r\n  Bottleneck.IORedisConnection = Bottleneck.prototype.IORedisConnection = __webpack_require__(/*! ./IORedisConnection */ \"./node_modules/bottleneck/lib/IORedisConnection.js\");\r\n  Bottleneck.Batcher = Bottleneck.prototype.Batcher = __webpack_require__(/*! ./Batcher */ \"./node_modules/bottleneck/lib/Batcher.js\");\r\n  Bottleneck.prototype.jobDefaults = {\r\n    priority: DEFAULT_PRIORITY,\r\n    weight: 1,\r\n    expiration: null,\r\n    id: \"<no-id>\"\r\n  };\r\n  Bottleneck.prototype.storeDefaults = {\r\n    maxConcurrent: null,\r\n    minTime: 0,\r\n    highWater: null,\r\n    strategy: Bottleneck.prototype.strategy.LEAK,\r\n    penalty: null,\r\n    reservoir: null,\r\n    reservoirRefreshInterval: null,\r\n    reservoirRefreshAmount: null,\r\n    reservoirIncreaseInterval: null,\r\n    reservoirIncreaseAmount: null,\r\n    reservoirIncreaseMaximum: null\r\n  };\r\n  Bottleneck.prototype.localStoreDefaults = {\r\n    Promise: Promise,\r\n    timeout: null,\r\n    heartbeatInterval: 250\r\n  };\r\n  Bottleneck.prototype.redisStoreDefaults = {\r\n    Promise: Promise,\r\n    timeout: null,\r\n    heartbeatInterval: 5000,\r\n    clientTimeout: 10000,\r\n    Redis: null,\r\n    clientOptions: {},\r\n    clusterNodes: null,\r\n    clearDatastore: false,\r\n    connection: null\r\n  };\r\n  Bottleneck.prototype.instanceDefaults = {\r\n    datastore: \"local\",\r\n    connection: null,\r\n    id: \"<no-id>\",\r\n    rejectOnDrop: true,\r\n    trackDoneStatus: false,\r\n    Promise: Promise\r\n  };\r\n  Bottleneck.prototype.stopDefaults = {\r\n    enqueueErrorMessage: \"This limiter has been stopped and cannot accept new jobs.\",\r\n    dropWaitingJobs: true,\r\n    dropErrorMessage: \"This limiter has been stopped.\"\r\n  };\r\n  return Bottleneck;\r\n}.call(void 0);\r\n\r\nmodule.exports = Bottleneck;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/Bottleneck.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/BottleneckError.js":
/*!********************************************************!*\
  !*** ./node_modules/bottleneck/lib/BottleneckError.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nvar BottleneckError;\r\nBottleneckError = class BottleneckError extends Error {};\r\nmodule.exports = BottleneckError;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/BottleneckError.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/DLList.js":
/*!***********************************************!*\
  !*** ./node_modules/bottleneck/lib/DLList.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nvar DLList;\r\nDLList = class DLList {\r\n  constructor(incr, decr) {\r\n    this.incr = incr;\r\n    this.decr = decr;\r\n    this._first = null;\r\n    this._last = null;\r\n    this.length = 0;\r\n  }\r\n\r\n  push(value) {\r\n    var node;\r\n    this.length++;\r\n\r\n    if (typeof this.incr === \"function\") {\r\n      this.incr();\r\n    }\r\n\r\n    node = {\r\n      value,\r\n      prev: this._last,\r\n      next: null\r\n    };\r\n\r\n    if (this._last != null) {\r\n      this._last.next = node;\r\n      this._last = node;\r\n    } else {\r\n      this._first = this._last = node;\r\n    }\r\n\r\n    return void 0;\r\n  }\r\n\r\n  shift() {\r\n    var value;\r\n\r\n    if (this._first == null) {\r\n      return;\r\n    } else {\r\n      this.length--;\r\n\r\n      if (typeof this.decr === \"function\") {\r\n        this.decr();\r\n      }\r\n    }\r\n\r\n    value = this._first.value;\r\n\r\n    if ((this._first = this._first.next) != null) {\r\n      this._first.prev = null;\r\n    } else {\r\n      this._last = null;\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  first() {\r\n    if (this._first != null) {\r\n      return this._first.value;\r\n    }\r\n  }\r\n\r\n  getArray() {\r\n    var node, ref, results;\r\n    node = this._first;\r\n    results = [];\r\n\r\n    while (node != null) {\r\n      results.push((ref = node, node = node.next, ref.value));\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  forEachShift(cb) {\r\n    var node;\r\n    node = this.shift();\r\n\r\n    while (node != null) {\r\n      cb(node), node = this.shift();\r\n    }\r\n\r\n    return void 0;\r\n  }\r\n\r\n  debug() {\r\n    var node, ref, ref1, ref2, results;\r\n    node = this._first;\r\n    results = [];\r\n\r\n    while (node != null) {\r\n      results.push((ref = node, node = node.next, {\r\n        value: ref.value,\r\n        prev: (ref1 = ref.prev) != null ? ref1.value : void 0,\r\n        next: (ref2 = ref.next) != null ? ref2.value : void 0\r\n      }));\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n};\r\nmodule.exports = DLList;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/DLList.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/Events.js":
/*!***********************************************!*\
  !*** ./node_modules/bottleneck/lib/Events.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\r\n\r\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\r\n\r\nvar Events;\r\nEvents = class Events {\r\n  constructor(instance) {\r\n    this.instance = instance;\r\n    this._events = {};\r\n\r\n    if (this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null) {\r\n      throw new Error(\"An Emitter already exists for this object\");\r\n    }\r\n\r\n    this.instance.on = (name, cb) => {\r\n      return this._addListener(name, \"many\", cb);\r\n    };\r\n\r\n    this.instance.once = (name, cb) => {\r\n      return this._addListener(name, \"once\", cb);\r\n    };\r\n\r\n    this.instance.removeAllListeners = (name = null) => {\r\n      if (name != null) {\r\n        return delete this._events[name];\r\n      } else {\r\n        return this._events = {};\r\n      }\r\n    };\r\n  }\r\n\r\n  _addListener(name, status, cb) {\r\n    var base;\r\n\r\n    if ((base = this._events)[name] == null) {\r\n      base[name] = [];\r\n    }\r\n\r\n    this._events[name].push({\r\n      cb,\r\n      status\r\n    });\r\n\r\n    return this.instance;\r\n  }\r\n\r\n  listenerCount(name) {\r\n    if (this._events[name] != null) {\r\n      return this._events[name].length;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  trigger(name, ...args) {\r\n    var _this = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      var e, promises;\r\n\r\n      try {\r\n        if (name !== \"debug\") {\r\n          _this.trigger(\"debug\", `Event triggered: ${name}`, args);\r\n        }\r\n\r\n        if (_this._events[name] == null) {\r\n          return;\r\n        }\r\n\r\n        _this._events[name] = _this._events[name].filter(function (listener) {\r\n          return listener.status !== \"none\";\r\n        });\r\n        promises = _this._events[name].map(\r\n        /*#__PURE__*/\r\n        function () {\r\n          var _ref = _asyncToGenerator(function* (listener) {\r\n            var e, returned;\r\n\r\n            if (listener.status === \"none\") {\r\n              return;\r\n            }\r\n\r\n            if (listener.status === \"once\") {\r\n              listener.status = \"none\";\r\n            }\r\n\r\n            try {\r\n              returned = typeof listener.cb === \"function\" ? listener.cb(...args) : void 0;\r\n\r\n              if (typeof (returned != null ? returned.then : void 0) === \"function\") {\r\n                return yield returned;\r\n              } else {\r\n                return returned;\r\n              }\r\n            } catch (error) {\r\n              e = error;\r\n\r\n              if (true) {\r\n                _this.trigger(\"error\", e);\r\n              }\r\n\r\n              return null;\r\n            }\r\n          });\r\n\r\n          return function (_x) {\r\n            return _ref.apply(this, arguments);\r\n          };\r\n        }());\r\n        return (yield Promise.all(promises)).find(function (x) {\r\n          return x != null;\r\n        });\r\n      } catch (error) {\r\n        e = error;\r\n\r\n        if (true) {\r\n          _this.trigger(\"error\", e);\r\n        }\r\n\r\n        return null;\r\n      }\r\n    })();\r\n  }\r\n\r\n};\r\nmodule.exports = Events;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/Events.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/Group.js":
/*!**********************************************!*\
  !*** ./node_modules/bottleneck/lib/Group.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\r\n\r\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\r\n\r\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\r\n\r\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\r\n\r\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\r\n\r\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\r\n\r\nvar Events, Group, IORedisConnection, RedisConnection, Scripts, parser;\r\nparser = __webpack_require__(/*! ./parser */ \"./node_modules/bottleneck/lib/parser.js\");\r\nEvents = __webpack_require__(/*! ./Events */ \"./node_modules/bottleneck/lib/Events.js\");\r\nRedisConnection = __webpack_require__(/*! ./RedisConnection */ \"./node_modules/bottleneck/lib/RedisConnection.js\");\r\nIORedisConnection = __webpack_require__(/*! ./IORedisConnection */ \"./node_modules/bottleneck/lib/IORedisConnection.js\");\r\nScripts = __webpack_require__(/*! ./Scripts */ \"./node_modules/bottleneck/lib/Scripts.js\");\r\n\r\nGroup = function () {\r\n  class Group {\r\n    constructor(limiterOptions = {}) {\r\n      this.deleteKey = this.deleteKey.bind(this);\r\n      this.limiterOptions = limiterOptions;\r\n      parser.load(this.limiterOptions, this.defaults, this);\r\n      this.Events = new Events(this);\r\n      this.instances = {};\r\n      this.Bottleneck = __webpack_require__(/*! ./Bottleneck */ \"./node_modules/bottleneck/lib/Bottleneck.js\");\r\n\r\n      this._startAutoCleanup();\r\n\r\n      this.sharedConnection = this.connection != null;\r\n\r\n      if (this.connection == null) {\r\n        if (this.limiterOptions.datastore === \"redis\") {\r\n          this.connection = new RedisConnection(Object.assign({}, this.limiterOptions, {\r\n            Events: this.Events\r\n          }));\r\n        } else if (this.limiterOptions.datastore === \"ioredis\") {\r\n          this.connection = new IORedisConnection(Object.assign({}, this.limiterOptions, {\r\n            Events: this.Events\r\n          }));\r\n        }\r\n      }\r\n    }\r\n\r\n    key(key = \"\") {\r\n      var ref;\r\n      return (ref = this.instances[key]) != null ? ref : (() => {\r\n        var limiter;\r\n        limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {\r\n          id: `${this.id}-${key}`,\r\n          timeout: this.timeout,\r\n          connection: this.connection\r\n        }));\r\n        this.Events.trigger(\"created\", limiter, key);\r\n        return limiter;\r\n      })();\r\n    }\r\n\r\n    deleteKey(key = \"\") {\r\n      var _this = this;\r\n\r\n      return _asyncToGenerator(function* () {\r\n        var deleted, instance;\r\n        instance = _this.instances[key];\r\n\r\n        if (_this.connection) {\r\n          deleted = yield _this.connection.__runCommand__(['del', ...Scripts.allKeys(`${_this.id}-${key}`)]);\r\n        }\r\n\r\n        if (instance != null) {\r\n          delete _this.instances[key];\r\n          yield instance.disconnect();\r\n        }\r\n\r\n        return instance != null || deleted > 0;\r\n      })();\r\n    }\r\n\r\n    limiters() {\r\n      var k, ref, results, v;\r\n      ref = this.instances;\r\n      results = [];\r\n\r\n      for (k in ref) {\r\n        v = ref[k];\r\n        results.push({\r\n          key: k,\r\n          limiter: v\r\n        });\r\n      }\r\n\r\n      return results;\r\n    }\r\n\r\n    keys() {\r\n      return Object.keys(this.instances);\r\n    }\r\n\r\n    clusterKeys() {\r\n      var _this2 = this;\r\n\r\n      return _asyncToGenerator(function* () {\r\n        var cursor, end, found, i, k, keys, len, next, start;\r\n\r\n        if (_this2.connection == null) {\r\n          return _this2.Promise.resolve(_this2.keys());\r\n        }\r\n\r\n        keys = [];\r\n        cursor = null;\r\n        start = `b_${_this2.id}-`.length;\r\n        end = \"_settings\".length;\r\n\r\n        while (cursor !== 0) {\r\n          var _ref = yield _this2.connection.__runCommand__([\"scan\", cursor != null ? cursor : 0, \"match\", `b_${_this2.id}-*_settings`, \"count\", 10000]);\r\n\r\n          var _ref2 = _slicedToArray(_ref, 2);\r\n\r\n          next = _ref2[0];\r\n          found = _ref2[1];\r\n          cursor = ~~next;\r\n\r\n          for (i = 0, len = found.length; i < len; i++) {\r\n            k = found[i];\r\n            keys.push(k.slice(start, -end));\r\n          }\r\n        }\r\n\r\n        return keys;\r\n      })();\r\n    }\r\n\r\n    _startAutoCleanup() {\r\n      var _this3 = this;\r\n\r\n      var base;\r\n      clearInterval(this.interval);\r\n      return typeof (base = this.interval = setInterval(\r\n      /*#__PURE__*/\r\n      _asyncToGenerator(function* () {\r\n        var e, k, ref, results, time, v;\r\n        time = Date.now();\r\n        ref = _this3.instances;\r\n        results = [];\r\n\r\n        for (k in ref) {\r\n          v = ref[k];\r\n\r\n          try {\r\n            if (yield v._store.__groupCheck__(time)) {\r\n              results.push(_this3.deleteKey(k));\r\n            } else {\r\n              results.push(void 0);\r\n            }\r\n          } catch (error) {\r\n            e = error;\r\n            results.push(v.Events.trigger(\"error\", e));\r\n          }\r\n        }\r\n\r\n        return results;\r\n      }), this.timeout / 2)).unref === \"function\" ? base.unref() : void 0;\r\n    }\r\n\r\n    updateSettings(options = {}) {\r\n      parser.overwrite(options, this.defaults, this);\r\n      parser.overwrite(options, options, this.limiterOptions);\r\n\r\n      if (options.timeout != null) {\r\n        return this._startAutoCleanup();\r\n      }\r\n    }\r\n\r\n    disconnect(flush = true) {\r\n      var ref;\r\n\r\n      if (!this.sharedConnection) {\r\n        return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  ;\r\n  Group.prototype.defaults = {\r\n    timeout: 1000 * 60 * 5,\r\n    connection: null,\r\n    Promise: Promise,\r\n    id: \"group-key\"\r\n  };\r\n  return Group;\r\n}.call(void 0);\r\n\r\nmodule.exports = Group;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/Group.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/IORedisConnection.js":
/*!**********************************************************!*\
  !*** ./node_modules/bottleneck/lib/IORedisConnection.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\r\n\r\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\r\n\r\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\r\n\r\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\r\n\r\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\r\n\r\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\r\n\r\nvar Events, IORedisConnection, Scripts, parser;\r\nparser = __webpack_require__(/*! ./parser */ \"./node_modules/bottleneck/lib/parser.js\");\r\nEvents = __webpack_require__(/*! ./Events */ \"./node_modules/bottleneck/lib/Events.js\");\r\nScripts = __webpack_require__(/*! ./Scripts */ \"./node_modules/bottleneck/lib/Scripts.js\");\r\n\r\nIORedisConnection = function () {\r\n  class IORedisConnection {\r\n    constructor(options = {}) {\r\n      parser.load(options, this.defaults, this);\r\n\r\n      if (this.Redis == null) {\r\n        this.Redis = eval(\"require\")(\"ioredis\"); // Obfuscated or else Webpack/Angular will try to inline the optional ioredis module. To override this behavior: pass the ioredis module to Bottleneck as the 'Redis' option.\r\n      }\r\n\r\n      if (this.Events == null) {\r\n        this.Events = new Events(this);\r\n      }\r\n\r\n      this.terminated = false;\r\n\r\n      if (this.clusterNodes != null) {\r\n        this.client = new this.Redis.Cluster(this.clusterNodes, this.clientOptions);\r\n        this.subscriber = new this.Redis.Cluster(this.clusterNodes, this.clientOptions);\r\n      } else if (this.client != null && this.client.duplicate == null) {\r\n        this.subscriber = new this.Redis.Cluster(this.client.startupNodes, this.client.options);\r\n      } else {\r\n        if (this.client == null) {\r\n          this.client = new this.Redis(this.clientOptions);\r\n        }\r\n\r\n        this.subscriber = this.client.duplicate();\r\n      }\r\n\r\n      this.limiters = {};\r\n      this.ready = this.Promise.all([this._setup(this.client, false), this._setup(this.subscriber, true)]).then(() => {\r\n        this._loadScripts();\r\n\r\n        return {\r\n          client: this.client,\r\n          subscriber: this.subscriber\r\n        };\r\n      });\r\n    }\r\n\r\n    _setup(client, sub) {\r\n      client.setMaxListeners(0);\r\n      return new this.Promise((resolve, reject) => {\r\n        client.on(\"error\", e => {\r\n          return this.Events.trigger(\"error\", e);\r\n        });\r\n\r\n        if (sub) {\r\n          client.on(\"message\", (channel, message) => {\r\n            var ref;\r\n            return (ref = this.limiters[channel]) != null ? ref._store.onMessage(channel, message) : void 0;\r\n          });\r\n        }\r\n\r\n        if (client.status === \"ready\") {\r\n          return resolve();\r\n        } else {\r\n          return client.once(\"ready\", resolve);\r\n        }\r\n      });\r\n    }\r\n\r\n    _loadScripts() {\r\n      return Scripts.names.forEach(name => {\r\n        return this.client.defineCommand(name, {\r\n          lua: Scripts.payload(name)\r\n        });\r\n      });\r\n    }\r\n\r\n    __runCommand__(cmd) {\r\n      var _this = this;\r\n\r\n      return _asyncToGenerator(function* () {\r\n        var _, deleted;\r\n\r\n        yield _this.ready;\r\n\r\n        var _ref = yield _this.client.pipeline([cmd]).exec();\r\n\r\n        var _ref2 = _slicedToArray(_ref, 1);\r\n\r\n        var _ref2$ = _slicedToArray(_ref2[0], 2);\r\n\r\n        _ = _ref2$[0];\r\n        deleted = _ref2$[1];\r\n        return deleted;\r\n      })();\r\n    }\r\n\r\n    __addLimiter__(instance) {\r\n      return this.Promise.all([instance.channel(), instance.channel_client()].map(channel => {\r\n        return new this.Promise((resolve, reject) => {\r\n          return this.subscriber.subscribe(channel, () => {\r\n            this.limiters[channel] = instance;\r\n            return resolve();\r\n          });\r\n        });\r\n      }));\r\n    }\r\n\r\n    __removeLimiter__(instance) {\r\n      var _this2 = this;\r\n\r\n      return [instance.channel(), instance.channel_client()].forEach(\r\n      /*#__PURE__*/\r\n      function () {\r\n        var _ref3 = _asyncToGenerator(function* (channel) {\r\n          if (!_this2.terminated) {\r\n            yield _this2.subscriber.unsubscribe(channel);\r\n          }\r\n\r\n          return delete _this2.limiters[channel];\r\n        });\r\n\r\n        return function (_x) {\r\n          return _ref3.apply(this, arguments);\r\n        };\r\n      }());\r\n    }\r\n\r\n    __scriptArgs__(name, id, args, cb) {\r\n      var keys;\r\n      keys = Scripts.keys(name, id);\r\n      return [keys.length].concat(keys, args, cb);\r\n    }\r\n\r\n    __scriptFn__(name) {\r\n      return this.client[name].bind(this.client);\r\n    }\r\n\r\n    disconnect(flush = true) {\r\n      var i, k, len, ref;\r\n      ref = Object.keys(this.limiters);\r\n\r\n      for (i = 0, len = ref.length; i < len; i++) {\r\n        k = ref[i];\r\n        clearInterval(this.limiters[k]._store.heartbeat);\r\n      }\r\n\r\n      this.limiters = {};\r\n      this.terminated = true;\r\n\r\n      if (flush) {\r\n        return this.Promise.all([this.client.quit(), this.subscriber.quit()]);\r\n      } else {\r\n        this.client.disconnect();\r\n        this.subscriber.disconnect();\r\n        return this.Promise.resolve();\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  ;\r\n  IORedisConnection.prototype.datastore = \"ioredis\";\r\n  IORedisConnection.prototype.defaults = {\r\n    Redis: null,\r\n    clientOptions: {},\r\n    clusterNodes: null,\r\n    client: null,\r\n    Promise: Promise,\r\n    Events: null\r\n  };\r\n  return IORedisConnection;\r\n}.call(void 0);\r\n\r\nmodule.exports = IORedisConnection;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/IORedisConnection.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/Job.js":
/*!********************************************!*\
  !*** ./node_modules/bottleneck/lib/Job.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\r\n\r\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\r\n\r\nvar BottleneckError, DEFAULT_PRIORITY, Job, NUM_PRIORITIES, parser;\r\nNUM_PRIORITIES = 10;\r\nDEFAULT_PRIORITY = 5;\r\nparser = __webpack_require__(/*! ./parser */ \"./node_modules/bottleneck/lib/parser.js\");\r\nBottleneckError = __webpack_require__(/*! ./BottleneckError */ \"./node_modules/bottleneck/lib/BottleneckError.js\");\r\nJob = class Job {\r\n  constructor(task, args, options, jobDefaults, rejectOnDrop, Events, _states, Promise) {\r\n    this.task = task;\r\n    this.args = args;\r\n    this.rejectOnDrop = rejectOnDrop;\r\n    this.Events = Events;\r\n    this._states = _states;\r\n    this.Promise = Promise;\r\n    this.options = parser.load(options, jobDefaults);\r\n    this.options.priority = this._sanitizePriority(this.options.priority);\r\n\r\n    if (this.options.id === jobDefaults.id) {\r\n      this.options.id = `${this.options.id}-${this._randomIndex()}`;\r\n    }\r\n\r\n    this.promise = new this.Promise((_resolve, _reject) => {\r\n      this._resolve = _resolve;\r\n      this._reject = _reject;\r\n    });\r\n    this.retryCount = 0;\r\n  }\r\n\r\n  _sanitizePriority(priority) {\r\n    var sProperty;\r\n    sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;\r\n\r\n    if (sProperty < 0) {\r\n      return 0;\r\n    } else if (sProperty > NUM_PRIORITIES - 1) {\r\n      return NUM_PRIORITIES - 1;\r\n    } else {\r\n      return sProperty;\r\n    }\r\n  }\r\n\r\n  _randomIndex() {\r\n    return Math.random().toString(36).slice(2);\r\n  }\r\n\r\n  doDrop({\r\n    error,\r\n    message = \"This job has been dropped by Bottleneck\"\r\n  } = {}) {\r\n    if (this._states.remove(this.options.id)) {\r\n      if (this.rejectOnDrop) {\r\n        this._reject(error != null ? error : new BottleneckError(message));\r\n      }\r\n\r\n      this.Events.trigger(\"dropped\", {\r\n        args: this.args,\r\n        options: this.options,\r\n        task: this.task,\r\n        promise: this.promise\r\n      });\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  _assertStatus(expected) {\r\n    var status;\r\n    status = this._states.jobStatus(this.options.id);\r\n\r\n    if (!(status === expected || expected === \"DONE\" && status === null)) {\r\n      throw new BottleneckError(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);\r\n    }\r\n  }\r\n\r\n  doReceive() {\r\n    this._states.start(this.options.id);\r\n\r\n    return this.Events.trigger(\"received\", {\r\n      args: this.args,\r\n      options: this.options\r\n    });\r\n  }\r\n\r\n  doQueue(reachedHWM, blocked) {\r\n    this._assertStatus(\"RECEIVED\");\r\n\r\n    this._states.next(this.options.id);\r\n\r\n    return this.Events.trigger(\"queued\", {\r\n      args: this.args,\r\n      options: this.options,\r\n      reachedHWM,\r\n      blocked\r\n    });\r\n  }\r\n\r\n  doRun() {\r\n    if (this.retryCount === 0) {\r\n      this._assertStatus(\"QUEUED\");\r\n\r\n      this._states.next(this.options.id);\r\n    } else {\r\n      this._assertStatus(\"EXECUTING\");\r\n    }\r\n\r\n    return this.Events.trigger(\"scheduled\", {\r\n      args: this.args,\r\n      options: this.options\r\n    });\r\n  }\r\n\r\n  doExecute(chained, clearGlobalState, run, free) {\r\n    var _this = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      var error, eventInfo, passed;\r\n\r\n      if (_this.retryCount === 0) {\r\n        _this._assertStatus(\"RUNNING\");\r\n\r\n        _this._states.next(_this.options.id);\r\n      } else {\r\n        _this._assertStatus(\"EXECUTING\");\r\n      }\r\n\r\n      eventInfo = {\r\n        args: _this.args,\r\n        options: _this.options,\r\n        retryCount: _this.retryCount\r\n      };\r\n\r\n      _this.Events.trigger(\"executing\", eventInfo);\r\n\r\n      try {\r\n        passed = yield chained != null ? chained.schedule(_this.options, _this.task, ..._this.args) : _this.task(..._this.args);\r\n\r\n        if (clearGlobalState()) {\r\n          _this.doDone(eventInfo);\r\n\r\n          yield free(_this.options, eventInfo);\r\n\r\n          _this._assertStatus(\"DONE\");\r\n\r\n          return _this._resolve(passed);\r\n        }\r\n      } catch (error1) {\r\n        error = error1;\r\n        return _this._onFailure(error, eventInfo, clearGlobalState, run, free);\r\n      }\r\n    })();\r\n  }\r\n\r\n  doExpire(clearGlobalState, run, free) {\r\n    var error, eventInfo;\r\n\r\n    if (this._states.jobStatus(this.options.id === \"RUNNING\")) {\r\n      this._states.next(this.options.id);\r\n    }\r\n\r\n    this._assertStatus(\"EXECUTING\");\r\n\r\n    eventInfo = {\r\n      args: this.args,\r\n      options: this.options,\r\n      retryCount: this.retryCount\r\n    };\r\n    error = new BottleneckError(`This job timed out after ${this.options.expiration} ms.`);\r\n    return this._onFailure(error, eventInfo, clearGlobalState, run, free);\r\n  }\r\n\r\n  _onFailure(error, eventInfo, clearGlobalState, run, free) {\r\n    var _this2 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      var retry, retryAfter;\r\n\r\n      if (clearGlobalState()) {\r\n        retry = yield _this2.Events.trigger(\"failed\", error, eventInfo);\r\n\r\n        if (retry != null) {\r\n          retryAfter = ~~retry;\r\n\r\n          _this2.Events.trigger(\"retry\", `Retrying ${_this2.options.id} after ${retryAfter} ms`, eventInfo);\r\n\r\n          _this2.retryCount++;\r\n          return run(retryAfter);\r\n        } else {\r\n          _this2.doDone(eventInfo);\r\n\r\n          yield free(_this2.options, eventInfo);\r\n\r\n          _this2._assertStatus(\"DONE\");\r\n\r\n          return _this2._reject(error);\r\n        }\r\n      }\r\n    })();\r\n  }\r\n\r\n  doDone(eventInfo) {\r\n    this._assertStatus(\"EXECUTING\");\r\n\r\n    this._states.next(this.options.id);\r\n\r\n    return this.Events.trigger(\"done\", eventInfo);\r\n  }\r\n\r\n};\r\nmodule.exports = Job;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/Job.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/LocalDatastore.js":
/*!*******************************************************!*\
  !*** ./node_modules/bottleneck/lib/LocalDatastore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\r\n\r\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\r\n\r\nvar BottleneckError, LocalDatastore, parser;\r\nparser = __webpack_require__(/*! ./parser */ \"./node_modules/bottleneck/lib/parser.js\");\r\nBottleneckError = __webpack_require__(/*! ./BottleneckError */ \"./node_modules/bottleneck/lib/BottleneckError.js\");\r\nLocalDatastore = class LocalDatastore {\r\n  constructor(instance, storeOptions, storeInstanceOptions) {\r\n    this.instance = instance;\r\n    this.storeOptions = storeOptions;\r\n    this.clientId = this.instance._randomIndex();\r\n    parser.load(storeInstanceOptions, storeInstanceOptions, this);\r\n    this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();\r\n    this._running = 0;\r\n    this._done = 0;\r\n    this._unblockTime = 0;\r\n    this.ready = this.Promise.resolve();\r\n    this.clients = {};\r\n\r\n    this._startHeartbeat();\r\n  }\r\n\r\n  _startHeartbeat() {\r\n    var base;\r\n\r\n    if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {\r\n      return typeof (base = this.heartbeat = setInterval(() => {\r\n        var amount, incr, maximum, now, reservoir;\r\n        now = Date.now();\r\n\r\n        if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {\r\n          this._lastReservoirRefresh = now;\r\n          this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;\r\n\r\n          this.instance._drainAll(this.computeCapacity());\r\n        }\r\n\r\n        if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {\r\n          var _this$storeOptions = this.storeOptions;\r\n          amount = _this$storeOptions.reservoirIncreaseAmount;\r\n          maximum = _this$storeOptions.reservoirIncreaseMaximum;\r\n          reservoir = _this$storeOptions.reservoir;\r\n          this._lastReservoirIncrease = now;\r\n          incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;\r\n\r\n          if (incr > 0) {\r\n            this.storeOptions.reservoir += incr;\r\n            return this.instance._drainAll(this.computeCapacity());\r\n          }\r\n        }\r\n      }, this.heartbeatInterval)).unref === \"function\" ? base.unref() : void 0;\r\n    } else {\r\n      return clearInterval(this.heartbeat);\r\n    }\r\n  }\r\n\r\n  __publish__(message) {\r\n    var _this = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      yield _this.yieldLoop();\r\n      return _this.instance.Events.trigger(\"message\", message.toString());\r\n    })();\r\n  }\r\n\r\n  __disconnect__(flush) {\r\n    var _this2 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      yield _this2.yieldLoop();\r\n      clearInterval(_this2.heartbeat);\r\n      return _this2.Promise.resolve();\r\n    })();\r\n  }\r\n\r\n  yieldLoop(t = 0) {\r\n    return new this.Promise(function (resolve, reject) {\r\n      return setTimeout(resolve, t);\r\n    });\r\n  }\r\n\r\n  computePenalty() {\r\n    var ref;\r\n    return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5000;\r\n  }\r\n\r\n  __updateSettings__(options) {\r\n    var _this3 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      yield _this3.yieldLoop();\r\n      parser.overwrite(options, options, _this3.storeOptions);\r\n\r\n      _this3._startHeartbeat();\r\n\r\n      _this3.instance._drainAll(_this3.computeCapacity());\r\n\r\n      return true;\r\n    })();\r\n  }\r\n\r\n  __running__() {\r\n    var _this4 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      yield _this4.yieldLoop();\r\n      return _this4._running;\r\n    })();\r\n  }\r\n\r\n  __queued__() {\r\n    var _this5 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      yield _this5.yieldLoop();\r\n      return _this5.instance.queued();\r\n    })();\r\n  }\r\n\r\n  __done__() {\r\n    var _this6 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      yield _this6.yieldLoop();\r\n      return _this6._done;\r\n    })();\r\n  }\r\n\r\n  __groupCheck__(time) {\r\n    var _this7 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      yield _this7.yieldLoop();\r\n      return _this7._nextRequest + _this7.timeout < time;\r\n    })();\r\n  }\r\n\r\n  computeCapacity() {\r\n    var maxConcurrent, reservoir;\r\n    var _this$storeOptions2 = this.storeOptions;\r\n    maxConcurrent = _this$storeOptions2.maxConcurrent;\r\n    reservoir = _this$storeOptions2.reservoir;\r\n\r\n    if (maxConcurrent != null && reservoir != null) {\r\n      return Math.min(maxConcurrent - this._running, reservoir);\r\n    } else if (maxConcurrent != null) {\r\n      return maxConcurrent - this._running;\r\n    } else if (reservoir != null) {\r\n      return reservoir;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  conditionsCheck(weight) {\r\n    var capacity;\r\n    capacity = this.computeCapacity();\r\n    return capacity == null || weight <= capacity;\r\n  }\r\n\r\n  __incrementReservoir__(incr) {\r\n    var _this8 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      var reservoir;\r\n      yield _this8.yieldLoop();\r\n      reservoir = _this8.storeOptions.reservoir += incr;\r\n\r\n      _this8.instance._drainAll(_this8.computeCapacity());\r\n\r\n      return reservoir;\r\n    })();\r\n  }\r\n\r\n  __currentReservoir__() {\r\n    var _this9 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      yield _this9.yieldLoop();\r\n      return _this9.storeOptions.reservoir;\r\n    })();\r\n  }\r\n\r\n  isBlocked(now) {\r\n    return this._unblockTime >= now;\r\n  }\r\n\r\n  check(weight, now) {\r\n    return this.conditionsCheck(weight) && this._nextRequest - now <= 0;\r\n  }\r\n\r\n  __check__(weight) {\r\n    var _this10 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      var now;\r\n      yield _this10.yieldLoop();\r\n      now = Date.now();\r\n      return _this10.check(weight, now);\r\n    })();\r\n  }\r\n\r\n  __register__(index, weight, expiration) {\r\n    var _this11 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      var now, wait;\r\n      yield _this11.yieldLoop();\r\n      now = Date.now();\r\n\r\n      if (_this11.conditionsCheck(weight)) {\r\n        _this11._running += weight;\r\n\r\n        if (_this11.storeOptions.reservoir != null) {\r\n          _this11.storeOptions.reservoir -= weight;\r\n        }\r\n\r\n        wait = Math.max(_this11._nextRequest - now, 0);\r\n        _this11._nextRequest = now + wait + _this11.storeOptions.minTime;\r\n        return {\r\n          success: true,\r\n          wait,\r\n          reservoir: _this11.storeOptions.reservoir\r\n        };\r\n      } else {\r\n        return {\r\n          success: false\r\n        };\r\n      }\r\n    })();\r\n  }\r\n\r\n  strategyIsBlock() {\r\n    return this.storeOptions.strategy === 3;\r\n  }\r\n\r\n  __submit__(queueLength, weight) {\r\n    var _this12 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      var blocked, now, reachedHWM;\r\n      yield _this12.yieldLoop();\r\n\r\n      if (_this12.storeOptions.maxConcurrent != null && weight > _this12.storeOptions.maxConcurrent) {\r\n        throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${_this12.storeOptions.maxConcurrent}`);\r\n      }\r\n\r\n      now = Date.now();\r\n      reachedHWM = _this12.storeOptions.highWater != null && queueLength === _this12.storeOptions.highWater && !_this12.check(weight, now);\r\n      blocked = _this12.strategyIsBlock() && (reachedHWM || _this12.isBlocked(now));\r\n\r\n      if (blocked) {\r\n        _this12._unblockTime = now + _this12.computePenalty();\r\n        _this12._nextRequest = _this12._unblockTime + _this12.storeOptions.minTime;\r\n\r\n        _this12.instance._dropAllQueued();\r\n      }\r\n\r\n      return {\r\n        reachedHWM,\r\n        blocked,\r\n        strategy: _this12.storeOptions.strategy\r\n      };\r\n    })();\r\n  }\r\n\r\n  __free__(index, weight) {\r\n    var _this13 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      yield _this13.yieldLoop();\r\n      _this13._running -= weight;\r\n      _this13._done += weight;\r\n\r\n      _this13.instance._drainAll(_this13.computeCapacity());\r\n\r\n      return {\r\n        running: _this13._running\r\n      };\r\n    })();\r\n  }\r\n\r\n};\r\nmodule.exports = LocalDatastore;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/LocalDatastore.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/Queues.js":
/*!***********************************************!*\
  !*** ./node_modules/bottleneck/lib/Queues.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar DLList, Events, Queues;\r\nDLList = __webpack_require__(/*! ./DLList */ \"./node_modules/bottleneck/lib/DLList.js\");\r\nEvents = __webpack_require__(/*! ./Events */ \"./node_modules/bottleneck/lib/Events.js\");\r\nQueues = class Queues {\r\n  constructor(num_priorities) {\r\n    var i;\r\n    this.Events = new Events(this);\r\n    this._length = 0;\r\n\r\n    this._lists = function () {\r\n      var j, ref, results;\r\n      results = [];\r\n\r\n      for (i = j = 1, ref = num_priorities; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\r\n        results.push(new DLList(() => {\r\n          return this.incr();\r\n        }, () => {\r\n          return this.decr();\r\n        }));\r\n      }\r\n\r\n      return results;\r\n    }.call(this);\r\n  }\r\n\r\n  incr() {\r\n    if (this._length++ === 0) {\r\n      return this.Events.trigger(\"leftzero\");\r\n    }\r\n  }\r\n\r\n  decr() {\r\n    if (--this._length === 0) {\r\n      return this.Events.trigger(\"zero\");\r\n    }\r\n  }\r\n\r\n  push(job) {\r\n    return this._lists[job.options.priority].push(job);\r\n  }\r\n\r\n  queued(priority) {\r\n    if (priority != null) {\r\n      return this._lists[priority].length;\r\n    } else {\r\n      return this._length;\r\n    }\r\n  }\r\n\r\n  shiftAll(fn) {\r\n    return this._lists.forEach(function (list) {\r\n      return list.forEachShift(fn);\r\n    });\r\n  }\r\n\r\n  getFirst(arr = this._lists) {\r\n    var j, len, list;\r\n\r\n    for (j = 0, len = arr.length; j < len; j++) {\r\n      list = arr[j];\r\n\r\n      if (list.length > 0) {\r\n        return list;\r\n      }\r\n    }\r\n\r\n    return [];\r\n  }\r\n\r\n  shiftLastFrom(priority) {\r\n    return this.getFirst(this._lists.slice(priority).reverse()).shift();\r\n  }\r\n\r\n};\r\nmodule.exports = Queues;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/Queues.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/RedisConnection.js":
/*!********************************************************!*\
  !*** ./node_modules/bottleneck/lib/RedisConnection.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\r\n\r\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\r\n\r\nvar Events, RedisConnection, Scripts, parser;\r\nparser = __webpack_require__(/*! ./parser */ \"./node_modules/bottleneck/lib/parser.js\");\r\nEvents = __webpack_require__(/*! ./Events */ \"./node_modules/bottleneck/lib/Events.js\");\r\nScripts = __webpack_require__(/*! ./Scripts */ \"./node_modules/bottleneck/lib/Scripts.js\");\r\n\r\nRedisConnection = function () {\r\n  class RedisConnection {\r\n    constructor(options = {}) {\r\n      parser.load(options, this.defaults, this);\r\n\r\n      if (this.Redis == null) {\r\n        this.Redis = eval(\"require\")(\"redis\"); // Obfuscated or else Webpack/Angular will try to inline the optional redis module. To override this behavior: pass the redis module to Bottleneck as the 'Redis' option.\r\n      }\r\n\r\n      if (this.Events == null) {\r\n        this.Events = new Events(this);\r\n      }\r\n\r\n      this.terminated = false;\r\n\r\n      if (this.client == null) {\r\n        this.client = this.Redis.createClient(this.clientOptions);\r\n      }\r\n\r\n      this.subscriber = this.client.duplicate();\r\n      this.limiters = {};\r\n      this.shas = {};\r\n      this.ready = this.Promise.all([this._setup(this.client, false), this._setup(this.subscriber, true)]).then(() => {\r\n        return this._loadScripts();\r\n      }).then(() => {\r\n        return {\r\n          client: this.client,\r\n          subscriber: this.subscriber\r\n        };\r\n      });\r\n    }\r\n\r\n    _setup(client, sub) {\r\n      client.setMaxListeners(0);\r\n      return new this.Promise((resolve, reject) => {\r\n        client.on(\"error\", e => {\r\n          return this.Events.trigger(\"error\", e);\r\n        });\r\n\r\n        if (sub) {\r\n          client.on(\"message\", (channel, message) => {\r\n            var ref;\r\n            return (ref = this.limiters[channel]) != null ? ref._store.onMessage(channel, message) : void 0;\r\n          });\r\n        }\r\n\r\n        if (client.ready) {\r\n          return resolve();\r\n        } else {\r\n          return client.once(\"ready\", resolve);\r\n        }\r\n      });\r\n    }\r\n\r\n    _loadScript(name) {\r\n      return new this.Promise((resolve, reject) => {\r\n        var payload;\r\n        payload = Scripts.payload(name);\r\n        return this.client.multi([[\"script\", \"load\", payload]]).exec((err, replies) => {\r\n          if (err != null) {\r\n            return reject(err);\r\n          }\r\n\r\n          this.shas[name] = replies[0];\r\n          return resolve(replies[0]);\r\n        });\r\n      });\r\n    }\r\n\r\n    _loadScripts() {\r\n      return this.Promise.all(Scripts.names.map(k => {\r\n        return this._loadScript(k);\r\n      }));\r\n    }\r\n\r\n    __runCommand__(cmd) {\r\n      var _this = this;\r\n\r\n      return _asyncToGenerator(function* () {\r\n        yield _this.ready;\r\n        return new _this.Promise((resolve, reject) => {\r\n          return _this.client.multi([cmd]).exec_atomic(function (err, replies) {\r\n            if (err != null) {\r\n              return reject(err);\r\n            } else {\r\n              return resolve(replies[0]);\r\n            }\r\n          });\r\n        });\r\n      })();\r\n    }\r\n\r\n    __addLimiter__(instance) {\r\n      return this.Promise.all([instance.channel(), instance.channel_client()].map(channel => {\r\n        return new this.Promise((resolve, reject) => {\r\n          var handler;\r\n\r\n          handler = chan => {\r\n            if (chan === channel) {\r\n              this.subscriber.removeListener(\"subscribe\", handler);\r\n              this.limiters[channel] = instance;\r\n              return resolve();\r\n            }\r\n          };\r\n\r\n          this.subscriber.on(\"subscribe\", handler);\r\n          return this.subscriber.subscribe(channel);\r\n        });\r\n      }));\r\n    }\r\n\r\n    __removeLimiter__(instance) {\r\n      var _this2 = this;\r\n\r\n      return this.Promise.all([instance.channel(), instance.channel_client()].map(\r\n      /*#__PURE__*/\r\n      function () {\r\n        var _ref = _asyncToGenerator(function* (channel) {\r\n          if (!_this2.terminated) {\r\n            yield new _this2.Promise((resolve, reject) => {\r\n              return _this2.subscriber.unsubscribe(channel, function (err, chan) {\r\n                if (err != null) {\r\n                  return reject(err);\r\n                }\r\n\r\n                if (chan === channel) {\r\n                  return resolve();\r\n                }\r\n              });\r\n            });\r\n          }\r\n\r\n          return delete _this2.limiters[channel];\r\n        });\r\n\r\n        return function (_x) {\r\n          return _ref.apply(this, arguments);\r\n        };\r\n      }()));\r\n    }\r\n\r\n    __scriptArgs__(name, id, args, cb) {\r\n      var keys;\r\n      keys = Scripts.keys(name, id);\r\n      return [this.shas[name], keys.length].concat(keys, args, cb);\r\n    }\r\n\r\n    __scriptFn__(name) {\r\n      return this.client.evalsha.bind(this.client);\r\n    }\r\n\r\n    disconnect(flush = true) {\r\n      var i, k, len, ref;\r\n      ref = Object.keys(this.limiters);\r\n\r\n      for (i = 0, len = ref.length; i < len; i++) {\r\n        k = ref[i];\r\n        clearInterval(this.limiters[k]._store.heartbeat);\r\n      }\r\n\r\n      this.limiters = {};\r\n      this.terminated = true;\r\n      this.client.end(flush);\r\n      this.subscriber.end(flush);\r\n      return this.Promise.resolve();\r\n    }\r\n\r\n  }\r\n\r\n  ;\r\n  RedisConnection.prototype.datastore = \"redis\";\r\n  RedisConnection.prototype.defaults = {\r\n    Redis: null,\r\n    clientOptions: {},\r\n    client: null,\r\n    Promise: Promise,\r\n    Events: null\r\n  };\r\n  return RedisConnection;\r\n}.call(void 0);\r\n\r\nmodule.exports = RedisConnection;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/RedisConnection.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/RedisDatastore.js":
/*!*******************************************************!*\
  !*** ./node_modules/bottleneck/lib/RedisDatastore.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\r\n\r\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\r\n\r\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\r\n\r\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\r\n\r\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\r\n\r\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\r\n\r\nvar BottleneckError, IORedisConnection, RedisConnection, RedisDatastore, parser;\r\nparser = __webpack_require__(/*! ./parser */ \"./node_modules/bottleneck/lib/parser.js\");\r\nBottleneckError = __webpack_require__(/*! ./BottleneckError */ \"./node_modules/bottleneck/lib/BottleneckError.js\");\r\nRedisConnection = __webpack_require__(/*! ./RedisConnection */ \"./node_modules/bottleneck/lib/RedisConnection.js\");\r\nIORedisConnection = __webpack_require__(/*! ./IORedisConnection */ \"./node_modules/bottleneck/lib/IORedisConnection.js\");\r\nRedisDatastore = class RedisDatastore {\r\n  constructor(instance, storeOptions, storeInstanceOptions) {\r\n    this.instance = instance;\r\n    this.storeOptions = storeOptions;\r\n    this.originalId = this.instance.id;\r\n    this.clientId = this.instance._randomIndex();\r\n    parser.load(storeInstanceOptions, storeInstanceOptions, this);\r\n    this.clients = {};\r\n    this.capacityPriorityCounters = {};\r\n    this.sharedConnection = this.connection != null;\r\n\r\n    if (this.connection == null) {\r\n      this.connection = this.instance.datastore === \"redis\" ? new RedisConnection({\r\n        Redis: this.Redis,\r\n        clientOptions: this.clientOptions,\r\n        Promise: this.Promise,\r\n        Events: this.instance.Events\r\n      }) : this.instance.datastore === \"ioredis\" ? new IORedisConnection({\r\n        Redis: this.Redis,\r\n        clientOptions: this.clientOptions,\r\n        clusterNodes: this.clusterNodes,\r\n        Promise: this.Promise,\r\n        Events: this.instance.Events\r\n      }) : void 0;\r\n    }\r\n\r\n    this.instance.connection = this.connection;\r\n    this.instance.datastore = this.connection.datastore;\r\n    this.ready = this.connection.ready.then(clients => {\r\n      this.clients = clients;\r\n      return this.runScript(\"init\", this.prepareInitSettings(this.clearDatastore));\r\n    }).then(() => {\r\n      return this.connection.__addLimiter__(this.instance);\r\n    }).then(() => {\r\n      return this.runScript(\"register_client\", [this.instance.queued()]);\r\n    }).then(() => {\r\n      var base;\r\n\r\n      if (typeof (base = this.heartbeat = setInterval(() => {\r\n        return this.runScript(\"heartbeat\", []).catch(e => {\r\n          return this.instance.Events.trigger(\"error\", e);\r\n        });\r\n      }, this.heartbeatInterval)).unref === \"function\") {\r\n        base.unref();\r\n      }\r\n\r\n      return this.clients;\r\n    });\r\n  }\r\n\r\n  __publish__(message) {\r\n    var _this = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      var client;\r\n\r\n      var _ref = yield _this.ready;\r\n\r\n      client = _ref.client;\r\n      return client.publish(_this.instance.channel(), `message:${message.toString()}`);\r\n    })();\r\n  }\r\n\r\n  onMessage(channel, message) {\r\n    var _this2 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      var capacity, counter, data, drained, e, newCapacity, pos, priorityClient, rawCapacity, type;\r\n\r\n      try {\r\n        pos = message.indexOf(\":\");\r\n        var _ref2 = [message.slice(0, pos), message.slice(pos + 1)];\r\n        type = _ref2[0];\r\n        data = _ref2[1];\r\n\r\n        if (type === \"capacity\") {\r\n          return yield _this2.instance._drainAll(data.length > 0 ? ~~data : void 0);\r\n        } else if (type === \"capacity-priority\") {\r\n          var _data$split = data.split(\":\");\r\n\r\n          var _data$split2 = _slicedToArray(_data$split, 3);\r\n\r\n          rawCapacity = _data$split2[0];\r\n          priorityClient = _data$split2[1];\r\n          counter = _data$split2[2];\r\n          capacity = rawCapacity.length > 0 ? ~~rawCapacity : void 0;\r\n\r\n          if (priorityClient === _this2.clientId) {\r\n            drained = yield _this2.instance._drainAll(capacity);\r\n            newCapacity = capacity != null ? capacity - (drained || 0) : \"\";\r\n            return yield _this2.clients.client.publish(_this2.instance.channel(), `capacity-priority:${newCapacity}::${counter}`);\r\n          } else if (priorityClient === \"\") {\r\n            clearTimeout(_this2.capacityPriorityCounters[counter]);\r\n            delete _this2.capacityPriorityCounters[counter];\r\n            return _this2.instance._drainAll(capacity);\r\n          } else {\r\n            return _this2.capacityPriorityCounters[counter] = setTimeout(\r\n            /*#__PURE__*/\r\n            _asyncToGenerator(function* () {\r\n              var e;\r\n\r\n              try {\r\n                delete _this2.capacityPriorityCounters[counter];\r\n                yield _this2.runScript(\"blacklist_client\", [priorityClient]);\r\n                return yield _this2.instance._drainAll(capacity);\r\n              } catch (error) {\r\n                e = error;\r\n                return _this2.instance.Events.trigger(\"error\", e);\r\n              }\r\n            }), 1000);\r\n          }\r\n        } else if (type === \"message\") {\r\n          return _this2.instance.Events.trigger(\"message\", data);\r\n        } else if (type === \"blocked\") {\r\n          return yield _this2.instance._dropAllQueued();\r\n        }\r\n      } catch (error) {\r\n        e = error;\r\n        return _this2.instance.Events.trigger(\"error\", e);\r\n      }\r\n    })();\r\n  }\r\n\r\n  __disconnect__(flush) {\r\n    clearInterval(this.heartbeat);\r\n\r\n    if (this.sharedConnection) {\r\n      return this.connection.__removeLimiter__(this.instance);\r\n    } else {\r\n      return this.connection.disconnect(flush);\r\n    }\r\n  }\r\n\r\n  runScript(name, args) {\r\n    var _this3 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      if (!(name === \"init\" || name === \"register_client\")) {\r\n        yield _this3.ready;\r\n      }\r\n\r\n      return new _this3.Promise((resolve, reject) => {\r\n        var all_args, arr;\r\n        all_args = [Date.now(), _this3.clientId].concat(args);\r\n\r\n        _this3.instance.Events.trigger(\"debug\", `Calling Redis script: ${name}.lua`, all_args);\r\n\r\n        arr = _this3.connection.__scriptArgs__(name, _this3.originalId, all_args, function (err, replies) {\r\n          if (err != null) {\r\n            return reject(err);\r\n          }\r\n\r\n          return resolve(replies);\r\n        });\r\n        return _this3.connection.__scriptFn__(name)(...arr);\r\n      }).catch(e => {\r\n        if (e.message === \"SETTINGS_KEY_NOT_FOUND\") {\r\n          if (name === \"heartbeat\") {\r\n            return _this3.Promise.resolve();\r\n          } else {\r\n            return _this3.runScript(\"init\", _this3.prepareInitSettings(false)).then(() => {\r\n              return _this3.runScript(name, args);\r\n            });\r\n          }\r\n        } else if (e.message === \"UNKNOWN_CLIENT\") {\r\n          return _this3.runScript(\"register_client\", [_this3.instance.queued()]).then(() => {\r\n            return _this3.runScript(name, args);\r\n          });\r\n        } else {\r\n          return _this3.Promise.reject(e);\r\n        }\r\n      });\r\n    })();\r\n  }\r\n\r\n  prepareArray(arr) {\r\n    var i, len, results, x;\r\n    results = [];\r\n\r\n    for (i = 0, len = arr.length; i < len; i++) {\r\n      x = arr[i];\r\n      results.push(x != null ? x.toString() : \"\");\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  prepareObject(obj) {\r\n    var arr, k, v;\r\n    arr = [];\r\n\r\n    for (k in obj) {\r\n      v = obj[k];\r\n      arr.push(k, v != null ? v.toString() : \"\");\r\n    }\r\n\r\n    return arr;\r\n  }\r\n\r\n  prepareInitSettings(clear) {\r\n    var args;\r\n    args = this.prepareObject(Object.assign({}, this.storeOptions, {\r\n      id: this.originalId,\r\n      version: this.instance.version,\r\n      groupTimeout: this.timeout,\r\n      clientTimeout: this.clientTimeout\r\n    }));\r\n    args.unshift(clear ? 1 : 0, this.instance.version);\r\n    return args;\r\n  }\r\n\r\n  convertBool(b) {\r\n    return !!b;\r\n  }\r\n\r\n  __updateSettings__(options) {\r\n    var _this4 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      yield _this4.runScript(\"update_settings\", _this4.prepareObject(options));\r\n      return parser.overwrite(options, options, _this4.storeOptions);\r\n    })();\r\n  }\r\n\r\n  __running__() {\r\n    return this.runScript(\"running\", []);\r\n  }\r\n\r\n  __queued__() {\r\n    return this.runScript(\"queued\", []);\r\n  }\r\n\r\n  __done__() {\r\n    return this.runScript(\"done\", []);\r\n  }\r\n\r\n  __groupCheck__() {\r\n    var _this5 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      return _this5.convertBool((yield _this5.runScript(\"group_check\", [])));\r\n    })();\r\n  }\r\n\r\n  __incrementReservoir__(incr) {\r\n    return this.runScript(\"increment_reservoir\", [incr]);\r\n  }\r\n\r\n  __currentReservoir__() {\r\n    return this.runScript(\"current_reservoir\", []);\r\n  }\r\n\r\n  __check__(weight) {\r\n    var _this6 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      return _this6.convertBool((yield _this6.runScript(\"check\", _this6.prepareArray([weight]))));\r\n    })();\r\n  }\r\n\r\n  __register__(index, weight, expiration) {\r\n    var _this7 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      var reservoir, success, wait;\r\n\r\n      var _ref4 = yield _this7.runScript(\"register\", _this7.prepareArray([index, weight, expiration]));\r\n\r\n      var _ref5 = _slicedToArray(_ref4, 3);\r\n\r\n      success = _ref5[0];\r\n      wait = _ref5[1];\r\n      reservoir = _ref5[2];\r\n      return {\r\n        success: _this7.convertBool(success),\r\n        wait,\r\n        reservoir\r\n      };\r\n    })();\r\n  }\r\n\r\n  __submit__(queueLength, weight) {\r\n    var _this8 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      var blocked, e, maxConcurrent, overweight, reachedHWM, strategy;\r\n\r\n      try {\r\n        var _ref6 = yield _this8.runScript(\"submit\", _this8.prepareArray([queueLength, weight]));\r\n\r\n        var _ref7 = _slicedToArray(_ref6, 3);\r\n\r\n        reachedHWM = _ref7[0];\r\n        blocked = _ref7[1];\r\n        strategy = _ref7[2];\r\n        return {\r\n          reachedHWM: _this8.convertBool(reachedHWM),\r\n          blocked: _this8.convertBool(blocked),\r\n          strategy\r\n        };\r\n      } catch (error) {\r\n        e = error;\r\n\r\n        if (e.message.indexOf(\"OVERWEIGHT\") === 0) {\r\n          var _e$message$split = e.message.split(\":\");\r\n\r\n          var _e$message$split2 = _slicedToArray(_e$message$split, 3);\r\n\r\n          overweight = _e$message$split2[0];\r\n          weight = _e$message$split2[1];\r\n          maxConcurrent = _e$message$split2[2];\r\n          throw new BottleneckError(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${maxConcurrent}`);\r\n        } else {\r\n          throw e;\r\n        }\r\n      }\r\n    })();\r\n  }\r\n\r\n  __free__(index, weight) {\r\n    var _this9 = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      var running;\r\n      running = yield _this9.runScript(\"free\", _this9.prepareArray([index]));\r\n      return {\r\n        running\r\n      };\r\n    })();\r\n  }\r\n\r\n};\r\nmodule.exports = RedisDatastore;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/RedisDatastore.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/Scripts.js":
/*!************************************************!*\
  !*** ./node_modules/bottleneck/lib/Scripts.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar headers, lua, templates;\r\nlua = __webpack_require__(/*! ./lua.json */ \"./node_modules/bottleneck/lib/lua.json\");\r\nheaders = {\r\n  refs: lua[\"refs.lua\"],\r\n  validate_keys: lua[\"validate_keys.lua\"],\r\n  validate_client: lua[\"validate_client.lua\"],\r\n  refresh_expiration: lua[\"refresh_expiration.lua\"],\r\n  process_tick: lua[\"process_tick.lua\"],\r\n  conditions_check: lua[\"conditions_check.lua\"],\r\n  get_time: lua[\"get_time.lua\"]\r\n};\r\n\r\nexports.allKeys = function (id) {\r\n  return [\r\n  /*\r\n  HASH\r\n  */\r\n  `b_${id}_settings`,\r\n  /*\r\n  HASH\r\n  job index -> weight\r\n  */\r\n  `b_${id}_job_weights`,\r\n  /*\r\n  ZSET\r\n  job index -> expiration\r\n  */\r\n  `b_${id}_job_expirations`,\r\n  /*\r\n  HASH\r\n  job index -> client\r\n  */\r\n  `b_${id}_job_clients`,\r\n  /*\r\n  ZSET\r\n  client -> sum running\r\n  */\r\n  `b_${id}_client_running`,\r\n  /*\r\n  HASH\r\n  client -> num queued\r\n  */\r\n  `b_${id}_client_num_queued`,\r\n  /*\r\n  ZSET\r\n  client -> last job registered\r\n  */\r\n  `b_${id}_client_last_registered`,\r\n  /*\r\n  ZSET\r\n  client -> last seen\r\n  */\r\n  `b_${id}_client_last_seen`];\r\n};\r\n\r\ntemplates = {\r\n  init: {\r\n    keys: exports.allKeys,\r\n    headers: [\"process_tick\"],\r\n    refresh_expiration: true,\r\n    code: lua[\"init.lua\"]\r\n  },\r\n  group_check: {\r\n    keys: exports.allKeys,\r\n    headers: [],\r\n    refresh_expiration: false,\r\n    code: lua[\"group_check.lua\"]\r\n  },\r\n  register_client: {\r\n    keys: exports.allKeys,\r\n    headers: [\"validate_keys\"],\r\n    refresh_expiration: false,\r\n    code: lua[\"register_client.lua\"]\r\n  },\r\n  blacklist_client: {\r\n    keys: exports.allKeys,\r\n    headers: [\"validate_keys\", \"validate_client\"],\r\n    refresh_expiration: false,\r\n    code: lua[\"blacklist_client.lua\"]\r\n  },\r\n  heartbeat: {\r\n    keys: exports.allKeys,\r\n    headers: [\"validate_keys\", \"validate_client\", \"process_tick\"],\r\n    refresh_expiration: false,\r\n    code: lua[\"heartbeat.lua\"]\r\n  },\r\n  update_settings: {\r\n    keys: exports.allKeys,\r\n    headers: [\"validate_keys\", \"validate_client\", \"process_tick\"],\r\n    refresh_expiration: true,\r\n    code: lua[\"update_settings.lua\"]\r\n  },\r\n  running: {\r\n    keys: exports.allKeys,\r\n    headers: [\"validate_keys\", \"validate_client\", \"process_tick\"],\r\n    refresh_expiration: false,\r\n    code: lua[\"running.lua\"]\r\n  },\r\n  queued: {\r\n    keys: exports.allKeys,\r\n    headers: [\"validate_keys\", \"validate_client\"],\r\n    refresh_expiration: false,\r\n    code: lua[\"queued.lua\"]\r\n  },\r\n  done: {\r\n    keys: exports.allKeys,\r\n    headers: [\"validate_keys\", \"validate_client\", \"process_tick\"],\r\n    refresh_expiration: false,\r\n    code: lua[\"done.lua\"]\r\n  },\r\n  check: {\r\n    keys: exports.allKeys,\r\n    headers: [\"validate_keys\", \"validate_client\", \"process_tick\", \"conditions_check\"],\r\n    refresh_expiration: false,\r\n    code: lua[\"check.lua\"]\r\n  },\r\n  submit: {\r\n    keys: exports.allKeys,\r\n    headers: [\"validate_keys\", \"validate_client\", \"process_tick\", \"conditions_check\"],\r\n    refresh_expiration: true,\r\n    code: lua[\"submit.lua\"]\r\n  },\r\n  register: {\r\n    keys: exports.allKeys,\r\n    headers: [\"validate_keys\", \"validate_client\", \"process_tick\", \"conditions_check\"],\r\n    refresh_expiration: true,\r\n    code: lua[\"register.lua\"]\r\n  },\r\n  free: {\r\n    keys: exports.allKeys,\r\n    headers: [\"validate_keys\", \"validate_client\", \"process_tick\"],\r\n    refresh_expiration: true,\r\n    code: lua[\"free.lua\"]\r\n  },\r\n  current_reservoir: {\r\n    keys: exports.allKeys,\r\n    headers: [\"validate_keys\", \"validate_client\", \"process_tick\"],\r\n    refresh_expiration: false,\r\n    code: lua[\"current_reservoir.lua\"]\r\n  },\r\n  increment_reservoir: {\r\n    keys: exports.allKeys,\r\n    headers: [\"validate_keys\", \"validate_client\", \"process_tick\"],\r\n    refresh_expiration: true,\r\n    code: lua[\"increment_reservoir.lua\"]\r\n  }\r\n};\r\nexports.names = Object.keys(templates);\r\n\r\nexports.keys = function (name, id) {\r\n  return templates[name].keys(id);\r\n};\r\n\r\nexports.payload = function (name) {\r\n  var template;\r\n  template = templates[name];\r\n  return Array.prototype.concat(headers.refs, template.headers.map(function (h) {\r\n    return headers[h];\r\n  }), template.refresh_expiration ? headers.refresh_expiration : \"\", template.code).join(\"\\n\");\r\n};\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/Scripts.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/States.js":
/*!***********************************************!*\
  !*** ./node_modules/bottleneck/lib/States.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nvar BottleneckError, States;\r\nBottleneckError = __webpack_require__(/*! ./BottleneckError */ \"./node_modules/bottleneck/lib/BottleneckError.js\");\r\nStates = class States {\r\n  constructor(status1) {\r\n    this.status = status1;\r\n    this._jobs = {};\r\n    this.counts = this.status.map(function () {\r\n      return 0;\r\n    });\r\n  }\r\n\r\n  next(id) {\r\n    var current, next;\r\n    current = this._jobs[id];\r\n    next = current + 1;\r\n\r\n    if (current != null && next < this.status.length) {\r\n      this.counts[current]--;\r\n      this.counts[next]++;\r\n      return this._jobs[id]++;\r\n    } else if (current != null) {\r\n      this.counts[current]--;\r\n      return delete this._jobs[id];\r\n    }\r\n  }\r\n\r\n  start(id) {\r\n    var initial;\r\n    initial = 0;\r\n    this._jobs[id] = initial;\r\n    return this.counts[initial]++;\r\n  }\r\n\r\n  remove(id) {\r\n    var current;\r\n    current = this._jobs[id];\r\n\r\n    if (current != null) {\r\n      this.counts[current]--;\r\n      delete this._jobs[id];\r\n    }\r\n\r\n    return current != null;\r\n  }\r\n\r\n  jobStatus(id) {\r\n    var ref;\r\n    return (ref = this.status[this._jobs[id]]) != null ? ref : null;\r\n  }\r\n\r\n  statusJobs(status) {\r\n    var k, pos, ref, results, v;\r\n\r\n    if (status != null) {\r\n      pos = this.status.indexOf(status);\r\n\r\n      if (pos < 0) {\r\n        throw new BottleneckError(`status must be one of ${this.status.join(', ')}`);\r\n      }\r\n\r\n      ref = this._jobs;\r\n      results = [];\r\n\r\n      for (k in ref) {\r\n        v = ref[k];\r\n\r\n        if (v === pos) {\r\n          results.push(k);\r\n        }\r\n      }\r\n\r\n      return results;\r\n    } else {\r\n      return Object.keys(this._jobs);\r\n    }\r\n  }\r\n\r\n  statusCounts() {\r\n    return this.counts.reduce((acc, v, i) => {\r\n      acc[this.status[i]] = v;\r\n      return acc;\r\n    }, {});\r\n  }\r\n\r\n};\r\nmodule.exports = States;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/States.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/Sync.js":
/*!*********************************************!*\
  !*** ./node_modules/bottleneck/lib/Sync.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\r\n\r\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\r\n\r\nvar DLList, Sync;\r\nDLList = __webpack_require__(/*! ./DLList */ \"./node_modules/bottleneck/lib/DLList.js\");\r\nSync = class Sync {\r\n  constructor(name, Promise) {\r\n    this.schedule = this.schedule.bind(this);\r\n    this.name = name;\r\n    this.Promise = Promise;\r\n    this._running = 0;\r\n    this._queue = new DLList();\r\n  }\r\n\r\n  isEmpty() {\r\n    return this._queue.length === 0;\r\n  }\r\n\r\n  _tryToRun() {\r\n    var _this = this;\r\n\r\n    return _asyncToGenerator(function* () {\r\n      var args, cb, error, reject, resolve, returned, task;\r\n\r\n      if (_this._running < 1 && _this._queue.length > 0) {\r\n        _this._running++;\r\n\r\n        var _this$_queue$shift = _this._queue.shift();\r\n\r\n        task = _this$_queue$shift.task;\r\n        args = _this$_queue$shift.args;\r\n        resolve = _this$_queue$shift.resolve;\r\n        reject = _this$_queue$shift.reject;\r\n        cb = yield _asyncToGenerator(function* () {\r\n          try {\r\n            returned = yield task(...args);\r\n            return function () {\r\n              return resolve(returned);\r\n            };\r\n          } catch (error1) {\r\n            error = error1;\r\n            return function () {\r\n              return reject(error);\r\n            };\r\n          }\r\n        })();\r\n        _this._running--;\r\n\r\n        _this._tryToRun();\r\n\r\n        return cb();\r\n      }\r\n    })();\r\n  }\r\n\r\n  schedule(task, ...args) {\r\n    var promise, reject, resolve;\r\n    resolve = reject = null;\r\n    promise = new this.Promise(function (_resolve, _reject) {\r\n      resolve = _resolve;\r\n      return reject = _reject;\r\n    });\r\n\r\n    this._queue.push({\r\n      task,\r\n      args,\r\n      resolve,\r\n      reject\r\n    });\r\n\r\n    this._tryToRun();\r\n\r\n    return promise;\r\n  }\r\n\r\n};\r\nmodule.exports = Sync;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/Sync.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/bottleneck/lib/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\nmodule.exports = __webpack_require__(/*! ./Bottleneck */ \"./node_modules/bottleneck/lib/Bottleneck.js\");\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/index.js?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/parser.js":
/*!***********************************************!*\
  !*** ./node_modules/bottleneck/lib/parser.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\n\r\nexports.load = function (received, defaults, onto = {}) {\r\n  var k, ref, v;\r\n\r\n  for (k in defaults) {\r\n    v = defaults[k];\r\n    onto[k] = (ref = received[k]) != null ? ref : v;\r\n  }\r\n\r\n  return onto;\r\n};\r\n\r\nexports.overwrite = function (received, defaults, onto = {}) {\r\n  var k, v;\r\n\r\n  for (k in received) {\r\n    v = received[k];\r\n\r\n    if (defaults[k] !== void 0) {\r\n      onto[k] = v;\r\n    }\r\n  }\r\n\r\n  return onto;\r\n};\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/parser.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style/style.scss":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style/style.scss ***!
  \*****************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/noSourceMaps.js */ \"./node_modules/css-loader/dist/runtime/noSourceMaps.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ \"./node_modules/css-loader/dist/runtime/getUrl.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);\n// Imports\n\n\n\nvar ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ./font/Montserrat/Montserrat-VariableFont_wght.ttf */ \"./src/style/font/Montserrat/Montserrat-VariableFont_wght.ttf\"), __webpack_require__.b);\nvar ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(/*! ./font/Hind/Hind-Regular.ttf */ \"./src/style/font/Hind/Hind-Regular.ttf\"), __webpack_require__.b);\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\nvar ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);\nvar ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/* CSS Reset */\n/* http://meyerweb.com/eric/tools/css/reset/ \n   v2.0 | 20110126\n   License: none (public domain)\n*/\nhtml,\nbody,\ndiv,\nspan,\napplet,\nobject,\niframe,\np,\nblockquote,\npre,\na,\nabbr,\nacronym,\naddress,\nbig,\ncite,\ncode,\ndel,\ndfn,\nem,\nimg,\nins,\nkbd,\nq,\ns,\nsamp,\nsmall,\nstrike,\nstrong,\nsub,\nsup,\ntt,\nvar,\nb,\nu,\ni,\ncenter,\ndl,\ndt,\ndd,\nfieldset,\nform,\nlabel,\nlegend,\ntable,\ncaption,\ntbody,\ntfoot,\nthead,\ntr,\nth,\ntd,\narticle,\naside,\ncanvas,\ndetails,\nembed,\nfigure,\nfigcaption,\nfooter,\nheader,\nhgroup,\nmenu,\nnav,\noutput,\nruby,\nsection,\nsummary,\ntime,\nmark,\naudio,\nvideo {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-size: 100%;\n  font: inherit;\n  vertical-align: baseline;\n}\n\n/* HTML5 display-role reset for older browsers */\narticle,\naside,\ndetails,\nfigcaption,\nfigure,\nfooter,\nheader,\nhgroup,\nmenu,\nnav,\nsection {\n  display: block;\n}\n\nbody,\nhtml {\n  height: 100%;\n}\n\nbody {\n  line-height: 1;\n}\n\nblockquote,\nq {\n  quotes: none;\n}\n\nblockquote:before,\nblockquote:after,\nq:before,\nq:after {\n  content: \"\";\n  content: none;\n}\n\ntable {\n  border-collapse: collapse;\n  border-spacing: 0;\n}\n\n/* End CSS Reset */\n@font-face {\n  font-family: Montserrat;\n  src: url(${___CSS_LOADER_URL_REPLACEMENT_0___});\n}\n@font-face {\n  font-family: Hind;\n  src: url(${___CSS_LOADER_URL_REPLACEMENT_1___});\n}\n:root {\n  --background: #fffefa;\n  --primary-color: #384b70;\n  --primary-color-faded: hsla(220, 17%, 17%, 0.5);\n  --secondary-color: #507687;\n  --tertiary-color: #dbe2ef;\n  --quaternary-color: #e07a29;\n  --text-color: #4a4b4d;\n  --text-font-size: 1rem;\n  --other-1: #768692;\n  --other-2: #a4bcc2;\n  --other-3: #d0d3d4;\n  --important: #b8001f;\n}\n\n.pop {\n  line-height: 1.5rem;\n}\n.pop .container {\n  border: 2px solid var(--primary-color);\n  background: var(--background);\n  padding: 30px 20px;\n  max-width: 700px;\n  margin: 0 auto;\n  display: flex;\n  flex-flow: column nowrap;\n  align-items: center;\n  position: relative;\n}\n.pop .closer {\n  content: \"\";\n  position: absolute;\n  right: 20px;\n  top: 20px;\n  cursor: pointer;\n  height: 25px;\n  width: 25px;\n  box-sizing: border-box;\n  border: none;\n  border-radius: 100%;\n  color: red;\n}\n.pop .closer::before, .pop .closer::after {\n  transition: width 50ms ease-in-out;\n  left: 47%;\n  content: \"\";\n  position: absolute;\n  background: var(--primary-color);\n  height: 20px;\n  width: 2px;\n  border-radius: 10px;\n  transform: rotate(45deg);\n  top: 0;\n}\n.pop .closer::after {\n  transform: rotate(-45deg);\n}\n.pop .closer:hover::before, .pop .closer:hover::after {\n  width: 3px;\n}\n\n.backdrop,\n.click-backdrop {\n  box-sizing: border-box;\n  position: absolute;\n  top: 0;\n  background: rgba(15, 15, 15, 0.4);\n  height: 100%;\n  width: 100%;\n  padding: 30px 20px;\n  overflow-y: scroll;\n  margin: auto 0;\n}\n\n.instructions img {\n  width: 100%;\n  height: auto;\n  max-width: 500px;\n}\n.instructions ul {\n  padding: 0 0 0 15px;\n}\n.instructions ol {\n  padding: 0 0 0 30px;\n}\n.instructions ul,\n.instructions ol {\n  display: flex;\n  flex-flow: column nowrap;\n  gap: 5px;\n  margin: 0 0 10px 0;\n}\n\nbody {\n  background: var(--background);\n  color: var(--text-color);\n  font-family: Hind, sans-serif;\n  font-size: var(--text-font-size);\n}\nbody .hidden {\n  display: none;\n}\nbody.no-scroll {\n  overflow-y: hidden;\n}\nbody a:hover {\n  text-decoration: none;\n}\nbody button {\n  padding: 10px;\n  color: var(--primary-color);\n  border: 2px solid var(--primary-color);\n  background: var(--background);\n  font-family: Hind, sans-serif;\n  font-weight: 600;\n  font-size: var(--text-font-size);\n  transition: all 60ms;\n}\n\nfooter {\n  padding: 5px;\n  display: flex;\n  flex-flow: column nowrap;\n  justify-content: center;\n  align-items: center;\n  gap: 5px;\n  box-sizing: border-box;\n  margin: 30px 0 20px 0;\n}\nfooter .github {\n  display: flex;\n  flex-flow: row nowrap;\n  align-items: flex-end;\n  gap: 5px;\n}\nfooter .logoImage {\n  transition: all 0.3s ease-in;\n  transform: rotate(0deg);\n}\nfooter .logoImage:hover {\n  transition: all 0.3s ease-in;\n  transform: rotate(360deg);\n}\nfooter ul {\n  list-style-type: none;\n  padding: 0;\n  margin: 0;\n}\n\nform {\n  display: flex;\n  flex-flow: column nowrap;\n  gap: 10px;\n}\nform .legend {\n  font-size: 0.8rem;\n}\nform .legend .required {\n  color: var(--important);\n}\nform button {\n  background: var(--primary-color);\n  color: var(--background);\n  border: 2px solid var(--secondary-color);\n}\nform button:hover {\n  cursor: pointer;\n  border: 2px solid var(--primary-color);\n  background: var(--background);\n  color: var(--primary-color);\n}\nform input {\n  height: 20px;\n  padding: 5px;\n}\nform input[type=file] {\n  padding: 5px 0;\n}\nform label {\n  color: var(--primary-color);\n  position: relative;\n  font-weight: 600;\n  font-size: 1.05rem;\n}\nform label.required::after {\n  content: \"*\";\n  position: absolute;\n  color: var(--important);\n}\nform #import {\n  margin-top: 15px;\n}\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-family: Montserrat;\n  color: var(--primary-color);\n  margin: 10px 0 25px 0;\n}\n\nh3,\nh4,\nh5,\nh6 {\n  margin: 5px 0 10px 0;\n}\n\n.header {\n  display: flex;\n  flex-flow: column nowrap;\n  justify-content: center;\n  align-items: center;\n  gap: 5px;\n  padding: 25px 0px;\n  text-align: center;\n}\n.header .logo .padlet_logo {\n  height: 100px;\n  width: auto;\n}\n\n.importing {\n  border: 5px solid red;\n}\n.importing .container {\n  border: 5px solid blue;\n}\n\n.main {\n  display: flex;\n  flex-flow: column nowrap;\n  margin: 0 auto;\n  gap: 20px;\n  padding: 0 10px;\n}\n\n@media only screen and (min-width: 767px) {\n  .header .logo .padlet_logo {\n    height: 120px;\n    width: auto;\n  }\n  .main {\n    max-width: 767px;\n  }\n}\n@media only screen and (min-width: 991px) {\n  .main {\n    gap: 30px;\n  }\n}`, \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://padlet-importing-script/./src/style/style.scss?./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = \"\";\n      var needLayer = typeof item[5] !== \"undefined\";\n      if (item[4]) {\n        content += \"@supports (\".concat(item[4], \") {\");\n      }\n      if (item[2]) {\n        content += \"@media \".concat(item[2], \" {\");\n      }\n      if (needLayer) {\n        content += \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += \"}\";\n      }\n      if (item[2]) {\n        content += \"}\";\n      }\n      if (item[4]) {\n        content += \"}\";\n      }\n      return content;\n    }).join(\"\");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === \"string\") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== \"undefined\") {\n        if (typeof item[5] === \"undefined\") {\n          item[5] = layer;\n        } else {\n          item[1] = \"@layer\".concat(item[5].length > 0 ? \" \".concat(item[5]) : \"\", \" {\").concat(item[1], \"}\");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = \"@media \".concat(item[2], \" {\").concat(item[1], \"}\");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = \"\".concat(supports);\n        } else {\n          item[1] = \"@supports (\".concat(item[4], \") {\").concat(item[1], \"}\");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    options = {};\n  }\n  if (!url) {\n    return url;\n  }\n  url = String(url.__esModule ? url.default : url);\n\n  // If url is already wrapped in quotes, remove them\n  if (/^['\"].*['\"]$/.test(url)) {\n    url = url.slice(1, -1);\n  }\n  if (options.hash) {\n    url += options.hash;\n  }\n\n  // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n  if (/[\"'() \\t\\n]|(%20)/.test(url) || options.needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\"), \"\\\"\");\n  }\n  return url;\n};\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/css-loader/dist/runtime/getUrl.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/noSourceMaps.js":
/*!**************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/noSourceMaps.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = function (i) {\n  return i[1];\n};\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/css-loader/dist/runtime/noSourceMaps.js?");

/***/ }),

/***/ "./node_modules/papaparse/papaparse.min.js":
/*!*************************************************!*\
  !*** ./node_modules/papaparse/papaparse.min.js ***!
  \*************************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* @license\r\nPapa Parse\r\nv5.4.1\r\nhttps://github.com/mholt/PapaParse\r\nLicense: MIT\r\n*/\r\n!function(e,t){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0}(this,function s(){\"use strict\";var f=\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:void 0!==f?f:{};var n=!f.document&&!!f.postMessage,o=f.IS_PAPA_WORKER||!1,a={},u=0,b={parse:function(e,t){var r=(t=t||{}).dynamicTyping||!1;J(r)&&(t.dynamicTypingFunction=r,r={});if(t.dynamicTyping=r,t.transform=!!J(t.transform)&&t.transform,t.worker&&b.WORKERS_SUPPORTED){var i=function(){if(!b.WORKERS_SUPPORTED)return!1;var e=(r=f.URL||f.webkitURL||null,i=s.toString(),b.BLOB_URL||(b.BLOB_URL=r.createObjectURL(new Blob([\"var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; \",\"(\",i,\")();\"],{type:\"text/javascript\"})))),t=new f.Worker(e);var r,i;return t.onmessage=_,t.id=u++,a[t.id]=t}();return i.userStep=t.step,i.userChunk=t.chunk,i.userComplete=t.complete,i.userError=t.error,t.step=J(t.step),t.chunk=J(t.chunk),t.complete=J(t.complete),t.error=J(t.error),delete t.worker,void i.postMessage({input:e,config:t,workerId:i.id})}var n=null;b.NODE_STREAM_INPUT,\"string\"==typeof e?(e=function(e){if(65279===e.charCodeAt(0))return e.slice(1);return e}(e),n=t.download?new l(t):new p(t)):!0===e.readable&&J(e.read)&&J(e.on)?n=new g(t):(f.File&&e instanceof File||e instanceof Object)&&(n=new c(t));return n.stream(e)},unparse:function(e,t){var n=!1,_=!0,m=\",\",y=\"\\r\\n\",s='\"',a=s+s,r=!1,i=null,o=!1;!function(){if(\"object\"!=typeof t)return;\"string\"!=typeof t.delimiter||b.BAD_DELIMITERS.filter(function(e){return-1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter);(\"boolean\"==typeof t.quotes||\"function\"==typeof t.quotes||Array.isArray(t.quotes))&&(n=t.quotes);\"boolean\"!=typeof t.skipEmptyLines&&\"string\"!=typeof t.skipEmptyLines||(r=t.skipEmptyLines);\"string\"==typeof t.newline&&(y=t.newline);\"string\"==typeof t.quoteChar&&(s=t.quoteChar);\"boolean\"==typeof t.header&&(_=t.header);if(Array.isArray(t.columns)){if(0===t.columns.length)throw new Error(\"Option columns is empty\");i=t.columns}void 0!==t.escapeChar&&(a=t.escapeChar+s);(\"boolean\"==typeof t.escapeFormulae||t.escapeFormulae instanceof RegExp)&&(o=t.escapeFormulae instanceof RegExp?t.escapeFormulae:/^[=+\\-@\\t\\r].*$/)}();var u=new RegExp(Q(s),\"g\");\"string\"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return h(null,e,r);if(\"object\"==typeof e[0])return h(i||Object.keys(e[0]),e,r)}else if(\"object\"==typeof e)return\"string\"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields||i),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:\"object\"==typeof e.data[0]?Object.keys(e.data[0]):[]),Array.isArray(e.data[0])||\"object\"==typeof e.data[0]||(e.data=[e.data])),h(e.fields||[],e.data||[],r);throw new Error(\"Unable to serialize unrecognized input\");function h(e,t,r){var i=\"\";\"string\"==typeof e&&(e=JSON.parse(e)),\"string\"==typeof t&&(t=JSON.parse(t));var n=Array.isArray(e)&&0<e.length,s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(i+=m),i+=v(e[a],a);0<t.length&&(i+=y)}for(var o=0;o<t.length;o++){var u=n?e.length:t[o].length,h=!1,f=n?0===Object.keys(t[o]).length:0===t[o].length;if(r&&!n&&(h=\"greedy\"===r?\"\"===t[o].join(\"\").trim():1===t[o].length&&0===t[o][0].length),\"greedy\"===r&&n){for(var d=[],l=0;l<u;l++){var c=s?e[l]:l;d.push(t[o][c])}h=\"\"===d.join(\"\").trim()}if(!h){for(var p=0;p<u;p++){0<p&&!f&&(i+=m);var g=n&&s?e[p]:p;i+=v(t[o][g],p)}o<t.length-1&&(!r||0<u&&!f)&&(i+=y)}}return i}function v(e,t){if(null==e)return\"\";if(e.constructor===Date)return JSON.stringify(e).slice(1,25);var r=!1;o&&\"string\"==typeof e&&o.test(e)&&(e=\"'\"+e,r=!0);var i=e.toString().replace(u,a);return(r=r||!0===n||\"function\"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||function(e,t){for(var r=0;r<t.length;r++)if(-1<e.indexOf(t[r]))return!0;return!1}(i,b.BAD_DELIMITERS)||-1<i.indexOf(m)||\" \"===i.charAt(0)||\" \"===i.charAt(i.length-1))?s+i+s:i}}};if(b.RECORD_SEP=String.fromCharCode(30),b.UNIT_SEP=String.fromCharCode(31),b.BYTE_ORDER_MARK=\"\\ufeff\",b.BAD_DELIMITERS=[\"\\r\",\"\\n\",'\"',b.BYTE_ORDER_MARK],b.WORKERS_SUPPORTED=!n&&!!f.Worker,b.NODE_STREAM_INPUT=1,b.LocalChunkSize=10485760,b.RemoteChunkSize=5242880,b.DefaultDelimiter=\",\",b.Parser=E,b.ParserHandle=r,b.NetworkStreamer=l,b.FileStreamer=c,b.StringStreamer=p,b.ReadableStreamStreamer=g,f.jQuery){var d=f.jQuery;d.fn.parse=function(o){var r=o.config||{},u=[];return this.each(function(e){if(!(\"INPUT\"===d(this).prop(\"tagName\").toUpperCase()&&\"file\"===d(this).attr(\"type\").toLowerCase()&&f.FileReader)||!this.files||0===this.files.length)return!0;for(var t=0;t<this.files.length;t++)u.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},r)})}),e(),this;function e(){if(0!==u.length){var e,t,r,i,n=u[0];if(J(o.before)){var s=o.before(n.file,n.inputElem);if(\"object\"==typeof s){if(\"abort\"===s.action)return e=\"AbortError\",t=n.file,r=n.inputElem,i=s.reason,void(J(o.error)&&o.error({name:e},t,r,i));if(\"skip\"===s.action)return void h();\"object\"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config))}else if(\"skip\"===s)return void h()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){J(a)&&a(e,n.file,n.inputElem),h()},b.parse(n.file,n.instanceConfig)}else J(o.complete)&&o.complete()}function h(){u.splice(0,1),e()}}}function h(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine=\"\",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=w(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new r(t),(this._handle.streamer=this)._config=t}.call(this,e),this.parseChunk=function(e,t){if(this.isFirstChunk&&J(this._config.beforeFirstChunk)){var r=this._config.beforeFirstChunk(e);void 0!==r&&(e=r)}this.isFirstChunk=!1,this._halted=!1;var i=this._partialLine+e;this._partialLine=\"\";var n=this._handle.parse(i,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var s=n.meta.cursor;this._finished||(this._partialLine=i.substring(s-this._baseIndex),this._baseIndex=s),n&&n.data&&(this._rowCount+=n.data.length);var a=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(o)f.postMessage({results:n,workerId:b.WORKER_ID,finished:a});else if(J(this._config.chunk)&&!t){if(this._config.chunk(n,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);n=void 0,this._completeResults=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(n.data),this._completeResults.errors=this._completeResults.errors.concat(n.errors),this._completeResults.meta=n.meta),this._completed||!a||!J(this._config.complete)||n&&n.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),a||n&&n.meta.paused||this._nextChunk(),n}this._halted=!0},this._sendError=function(e){J(this._config.error)?this._config.error(e):o&&this._config.error&&f.postMessage({workerId:b.WORKER_ID,error:e,finished:!1})}}function l(e){var i;(e=e||{}).chunkSize||(e.chunkSize=b.RemoteChunkSize),h.call(this,e),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(e){this._input=e,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(i=new XMLHttpRequest,this._config.withCredentials&&(i.withCredentials=this._config.withCredentials),n||(i.onload=v(this._chunkLoaded,this),i.onerror=v(this._chunkError,this)),i.open(this._config.downloadRequestBody?\"POST\":\"GET\",this._input,!n),this._config.downloadRequestHeaders){var e=this._config.downloadRequestHeaders;for(var t in e)i.setRequestHeader(t,e[t])}if(this._config.chunkSize){var r=this._start+this._config.chunkSize-1;i.setRequestHeader(\"Range\",\"bytes=\"+this._start+\"-\"+r)}try{i.send(this._config.downloadRequestBody)}catch(e){this._chunkError(e.message)}n&&0===i.status&&this._chunkError()}},this._chunkLoaded=function(){4===i.readyState&&(i.status<200||400<=i.status?this._chunkError():(this._start+=this._config.chunkSize?this._config.chunkSize:i.responseText.length,this._finished=!this._config.chunkSize||this._start>=function(e){var t=e.getResponseHeader(\"Content-Range\");if(null===t)return-1;return parseInt(t.substring(t.lastIndexOf(\"/\")+1))}(i),this.parseChunk(i.responseText)))},this._chunkError=function(e){var t=i.statusText||e;this._sendError(new Error(t))}}function c(e){var i,n;(e=e||{}).chunkSize||(e.chunkSize=b.LocalChunkSize),h.call(this,e);var s=\"undefined\"!=typeof FileReader;this.stream=function(e){this._input=e,n=e.slice||e.webkitSlice||e.mozSlice,s?((i=new FileReader).onload=v(this._chunkLoaded,this),i.onerror=v(this._chunkError,this)):i=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var e=this._input;if(this._config.chunkSize){var t=Math.min(this._start+this._config.chunkSize,this._input.size);e=n.call(e,this._start,t)}var r=i.readAsText(e,this._config.encoding);s||this._chunkLoaded({target:{result:r}})},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result)},this._chunkError=function(){this._sendError(i.error)}}function p(e){var r;h.call(this,e=e||{}),this.stream=function(e){return r=e,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var e,t=this._config.chunkSize;return t?(e=r.substring(0,t),r=r.substring(t)):(e=r,r=\"\"),this._finished=!r,this.parseChunk(e)}}}function g(e){h.call(this,e=e||{});var t=[],r=!0,i=!1;this.pause=function(){h.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){h.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(e){this._input=e,this._input.on(\"data\",this._streamData),this._input.on(\"end\",this._streamEnd),this._input.on(\"error\",this._streamError)},this._checkIsFinished=function(){i&&1===t.length&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):r=!0},this._streamData=v(function(e){try{t.push(\"string\"==typeof e?e:e.toString(this._config.encoding)),r&&(r=!1,this._checkIsFinished(),this.parseChunk(t.shift()))}catch(e){this._streamError(e)}},this),this._streamError=v(function(e){this._streamCleanUp(),this._sendError(e)},this),this._streamEnd=v(function(){this._streamCleanUp(),i=!0,this._streamData(\"\")},this),this._streamCleanUp=v(function(){this._input.removeListener(\"data\",this._streamData),this._input.removeListener(\"end\",this._streamEnd),this._input.removeListener(\"error\",this._streamError)},this)}function r(m){var a,o,u,i=Math.pow(2,53),n=-i,s=/^\\s*-?(\\d+\\.?|\\.\\d+|\\d+\\.\\d+)([eE][-+]?\\d+)?\\s*$/,h=/^((\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z)))$/,t=this,r=0,f=0,d=!1,e=!1,l=[],c={data:[],errors:[],meta:{}};if(J(m.step)){var p=m.step;m.step=function(e){if(c=e,_())g();else{if(g(),0===c.data.length)return;r+=e.data.length,m.preview&&r>m.preview?o.abort():(c.data=c.data[0],p(c,t))}}}function y(e){return\"greedy\"===m.skipEmptyLines?\"\"===e.join(\"\").trim():1===e.length&&0===e[0].length}function g(){return c&&u&&(k(\"Delimiter\",\"UndetectableDelimiter\",\"Unable to auto-detect delimiting character; defaulted to '\"+b.DefaultDelimiter+\"'\"),u=!1),m.skipEmptyLines&&(c.data=c.data.filter(function(e){return!y(e)})),_()&&function(){if(!c)return;function e(e,t){J(m.transformHeader)&&(e=m.transformHeader(e,t)),l.push(e)}if(Array.isArray(c.data[0])){for(var t=0;_()&&t<c.data.length;t++)c.data[t].forEach(e);c.data.splice(0,1)}else c.data.forEach(e)}(),function(){if(!c||!m.header&&!m.dynamicTyping&&!m.transform)return c;function e(e,t){var r,i=m.header?{}:[];for(r=0;r<e.length;r++){var n=r,s=e[r];m.header&&(n=r>=l.length?\"__parsed_extra\":l[r]),m.transform&&(s=m.transform(s,n)),s=v(n,s),\"__parsed_extra\"===n?(i[n]=i[n]||[],i[n].push(s)):i[n]=s}return m.header&&(r>l.length?k(\"FieldMismatch\",\"TooManyFields\",\"Too many fields: expected \"+l.length+\" fields but parsed \"+r,f+t):r<l.length&&k(\"FieldMismatch\",\"TooFewFields\",\"Too few fields: expected \"+l.length+\" fields but parsed \"+r,f+t)),i}var t=1;!c.data.length||Array.isArray(c.data[0])?(c.data=c.data.map(e),t=c.data.length):c.data=e(c.data,0);m.header&&c.meta&&(c.meta.fields=l);return f+=t,c}()}function _(){return m.header&&0===l.length}function v(e,t){return r=e,m.dynamicTypingFunction&&void 0===m.dynamicTyping[r]&&(m.dynamicTyping[r]=m.dynamicTypingFunction(r)),!0===(m.dynamicTyping[r]||m.dynamicTyping)?\"true\"===t||\"TRUE\"===t||\"false\"!==t&&\"FALSE\"!==t&&(function(e){if(s.test(e)){var t=parseFloat(e);if(n<t&&t<i)return!0}return!1}(t)?parseFloat(t):h.test(t)?new Date(t):\"\"===t?null:t):t;var r}function k(e,t,r,i){var n={type:e,code:t,message:r};void 0!==i&&(n.row=i),c.errors.push(n)}this.parse=function(e,t,r){var i=m.quoteChar||'\"';if(m.newline||(m.newline=function(e,t){e=e.substring(0,1048576);var r=new RegExp(Q(t)+\"([^]*?)\"+Q(t),\"gm\"),i=(e=e.replace(r,\"\")).split(\"\\r\"),n=e.split(\"\\n\"),s=1<n.length&&n[0].length<i[0].length;if(1===i.length||s)return\"\\n\";for(var a=0,o=0;o<i.length;o++)\"\\n\"===i[o][0]&&a++;return a>=i.length/2?\"\\r\\n\":\"\\r\"}(e,i)),u=!1,m.delimiter)J(m.delimiter)&&(m.delimiter=m.delimiter(e),c.meta.delimiter=m.delimiter);else{var n=function(e,t,r,i,n){var s,a,o,u;n=n||[\",\",\"\\t\",\"|\",\";\",b.RECORD_SEP,b.UNIT_SEP];for(var h=0;h<n.length;h++){var f=n[h],d=0,l=0,c=0;o=void 0;for(var p=new E({comments:i,delimiter:f,newline:t,preview:10}).parse(e),g=0;g<p.data.length;g++)if(r&&y(p.data[g]))c++;else{var _=p.data[g].length;l+=_,void 0!==o?0<_&&(d+=Math.abs(_-o),o=_):o=_}0<p.data.length&&(l/=p.data.length-c),(void 0===a||d<=a)&&(void 0===u||u<l)&&1.99<l&&(a=d,s=f,u=l)}return{successful:!!(m.delimiter=s),bestDelimiter:s}}(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess);n.successful?m.delimiter=n.bestDelimiter:(u=!0,m.delimiter=b.DefaultDelimiter),c.meta.delimiter=m.delimiter}var s=w(m);return m.preview&&m.header&&s.preview++,a=e,o=new E(s),c=o.parse(a,t,r),g(),d?{meta:{paused:!0}}:c||{meta:{paused:!1}}},this.paused=function(){return d},this.pause=function(){d=!0,o.abort(),a=J(m.chunk)?\"\":a.substring(o.getCharIndex())},this.resume=function(){t.streamer._halted?(d=!1,t.streamer.parseChunk(a,!0)):setTimeout(t.resume,3)},this.aborted=function(){return e},this.abort=function(){e=!0,o.abort(),c.meta.aborted=!0,J(m.complete)&&m.complete(c),a=\"\"}}function Q(e){return e.replace(/[.*+?^${}()|[\\]\\\\]/g,\"\\\\$&\")}function E(j){var z,M=(j=j||{}).delimiter,P=j.newline,U=j.comments,q=j.step,N=j.preview,B=j.fastMode,K=z=void 0===j.quoteChar||null===j.quoteChar?'\"':j.quoteChar;if(void 0!==j.escapeChar&&(K=j.escapeChar),(\"string\"!=typeof M||-1<b.BAD_DELIMITERS.indexOf(M))&&(M=\",\"),U===M)throw new Error(\"Comment character same as delimiter\");!0===U?U=\"#\":(\"string\"!=typeof U||-1<b.BAD_DELIMITERS.indexOf(U))&&(U=!1),\"\\n\"!==P&&\"\\r\"!==P&&\"\\r\\n\"!==P&&(P=\"\\n\");var W=0,H=!1;this.parse=function(i,t,r){if(\"string\"!=typeof i)throw new Error(\"Input must be a string\");var n=i.length,e=M.length,s=P.length,a=U.length,o=J(q),u=[],h=[],f=[],d=W=0;if(!i)return L();if(j.header&&!t){var l=i.split(P)[0].split(M),c=[],p={},g=!1;for(var _ in l){var m=l[_];J(j.transformHeader)&&(m=j.transformHeader(m,_));var y=m,v=p[m]||0;for(0<v&&(g=!0,y=m+\"_\"+v),p[m]=v+1;c.includes(y);)y=y+\"_\"+v;c.push(y)}if(g){var k=i.split(P);k[0]=c.join(M),i=k.join(P)}}if(B||!1!==B&&-1===i.indexOf(z)){for(var b=i.split(P),E=0;E<b.length;E++){if(f=b[E],W+=f.length,E!==b.length-1)W+=P.length;else if(r)return L();if(!U||f.substring(0,a)!==U){if(o){if(u=[],I(f.split(M)),F(),H)return L()}else I(f.split(M));if(N&&N<=E)return u=u.slice(0,N),L(!0)}}return L()}for(var w=i.indexOf(M,W),R=i.indexOf(P,W),C=new RegExp(Q(K)+Q(z),\"g\"),S=i.indexOf(z,W);;)if(i[W]!==z)if(U&&0===f.length&&i.substring(W,W+a)===U){if(-1===R)return L();W=R+s,R=i.indexOf(P,W),w=i.indexOf(M,W)}else if(-1!==w&&(w<R||-1===R))f.push(i.substring(W,w)),W=w+e,w=i.indexOf(M,W);else{if(-1===R)break;if(f.push(i.substring(W,R)),D(R+s),o&&(F(),H))return L();if(N&&u.length>=N)return L(!0)}else for(S=W,W++;;){if(-1===(S=i.indexOf(z,S+1)))return r||h.push({type:\"Quotes\",code:\"MissingQuotes\",message:\"Quoted field unterminated\",row:u.length,index:W}),T();if(S===n-1)return T(i.substring(W,S).replace(C,z));if(z!==K||i[S+1]!==K){if(z===K||0===S||i[S-1]!==K){-1!==w&&w<S+1&&(w=i.indexOf(M,S+1)),-1!==R&&R<S+1&&(R=i.indexOf(P,S+1));var O=A(-1===R?w:Math.min(w,R));if(i.substr(S+1+O,e)===M){f.push(i.substring(W,S).replace(C,z)),i[W=S+1+O+e]!==z&&(S=i.indexOf(z,W)),w=i.indexOf(M,W),R=i.indexOf(P,W);break}var x=A(R);if(i.substring(S+1+x,S+1+x+s)===P){if(f.push(i.substring(W,S).replace(C,z)),D(S+1+x+s),w=i.indexOf(M,W),S=i.indexOf(z,W),o&&(F(),H))return L();if(N&&u.length>=N)return L(!0);break}h.push({type:\"Quotes\",code:\"InvalidQuotes\",message:\"Trailing quote on quoted field is malformed\",row:u.length,index:W}),S++}}else S++}return T();function I(e){u.push(e),d=W}function A(e){var t=0;if(-1!==e){var r=i.substring(S+1,e);r&&\"\"===r.trim()&&(t=r.length)}return t}function T(e){return r||(void 0===e&&(e=i.substring(W)),f.push(e),W=n,I(f),o&&F()),L()}function D(e){W=e,I(f),f=[],R=i.indexOf(P,W)}function L(e){return{data:u,errors:h,meta:{delimiter:M,linebreak:P,aborted:H,truncated:!!e,cursor:d+(t||0)}}}function F(){q(L()),u=[],h=[]}},this.abort=function(){H=!0},this.getCharIndex=function(){return W}}function _(e){var t=e.data,r=a[t.workerId],i=!1;if(t.error)r.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){i=!0,m(t.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:y,resume:y};if(J(r.userStep)){for(var s=0;s<t.results.data.length&&(r.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!i);s++);delete t.results}else J(r.userChunk)&&(r.userChunk(t.results,n,t.file),delete t.results)}t.finished&&!i&&m(t.workerId,t.results)}function m(e,t){var r=a[e];J(r.userComplete)&&r.userComplete(t),r.terminate(),delete a[e]}function y(){throw new Error(\"Not implemented.\")}function w(e){if(\"object\"!=typeof e||null===e)return e;var t=Array.isArray(e)?[]:{};for(var r in e)t[r]=w(e[r]);return t}function v(e,t){return function(){e.apply(t,arguments)}}function J(e){return\"function\"==typeof e}return o&&(f.onmessage=function(e){var t=e.data;void 0===b.WORKER_ID&&t&&(b.WORKER_ID=t.workerId);if(\"string\"==typeof t.input)f.postMessage({workerId:b.WORKER_ID,results:b.parse(t.input,t.config),finished:!0});else if(f.File&&t.input instanceof File||t.input instanceof Object){var r=b.parse(t.input,t.config);r&&f.postMessage({workerId:b.WORKER_ID,results:r,finished:!0})}}),(l.prototype=Object.create(h.prototype)).constructor=l,(c.prototype=Object.create(h.prototype)).constructor=c,(p.prototype=Object.create(p.prototype)).constructor=p,(g.prototype=Object.create(h.prototype)).constructor=g,b});\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/papaparse/papaparse.min.js?");

/***/ }),

/***/ "./src/style/style.scss":
/*!******************************!*\
  !*** ./src/style/style.scss ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ \"./node_modules/style-loader/dist/runtime/styleDomAPI.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ \"./node_modules/style-loader/dist/runtime/insertBySelector.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ \"./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ \"./node_modules/style-loader/dist/runtime/insertStyleElement.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ \"./node_modules/style-loader/dist/runtime/styleTagTransform.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!../../node_modules/postcss-loader/dist/cjs.js!../../node_modules/sass-loader/dist/cjs.js!./style.scss */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./node_modules/sass-loader/dist/cjs.js!./src/style/style.scss\");\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());\noptions.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());\noptions.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, \"head\");\noptions.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());\noptions.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"], options);\n\n\n\n\n       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"] && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_node_modules_sass_loader_dist_cjs_js_style_scss__WEBPACK_IMPORTED_MODULE_6__[\"default\"].locals : undefined);\n\n\n//# sourceURL=webpack://padlet-importing-script/./src/style/style.scss?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nvar stylesInDOM = [];\r\nfunction getIndexByIdentifier(identifier) {\r\n  var result = -1;\r\n  for (var i = 0; i < stylesInDOM.length; i++) {\r\n    if (stylesInDOM[i].identifier === identifier) {\r\n      result = i;\r\n      break;\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction modulesToDom(list, options) {\r\n  var idCountMap = {};\r\n  var identifiers = [];\r\n  for (var i = 0; i < list.length; i++) {\r\n    var item = list[i];\r\n    var id = options.base ? item[0] + options.base : item[0];\r\n    var count = idCountMap[id] || 0;\r\n    var identifier = \"\".concat(id, \" \").concat(count);\r\n    idCountMap[id] = count + 1;\r\n    var indexByIdentifier = getIndexByIdentifier(identifier);\r\n    var obj = {\r\n      css: item[1],\r\n      media: item[2],\r\n      sourceMap: item[3],\r\n      supports: item[4],\r\n      layer: item[5]\r\n    };\r\n    if (indexByIdentifier !== -1) {\r\n      stylesInDOM[indexByIdentifier].references++;\r\n      stylesInDOM[indexByIdentifier].updater(obj);\r\n    } else {\r\n      var updater = addElementStyle(obj, options);\r\n      options.byIndex = i;\r\n      stylesInDOM.splice(i, 0, {\r\n        identifier: identifier,\r\n        updater: updater,\r\n        references: 1\r\n      });\r\n    }\r\n    identifiers.push(identifier);\r\n  }\r\n  return identifiers;\r\n}\r\nfunction addElementStyle(obj, options) {\r\n  var api = options.domAPI(options);\r\n  api.update(obj);\r\n  var updater = function updater(newObj) {\r\n    if (newObj) {\r\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\r\n        return;\r\n      }\r\n      api.update(obj = newObj);\r\n    } else {\r\n      api.remove();\r\n    }\r\n  };\r\n  return updater;\r\n}\r\nmodule.exports = function (list, options) {\r\n  options = options || {};\r\n  list = list || [];\r\n  var lastIdentifiers = modulesToDom(list, options);\r\n  return function update(newList) {\r\n    newList = newList || [];\r\n    for (var i = 0; i < lastIdentifiers.length; i++) {\r\n      var identifier = lastIdentifiers[i];\r\n      var index = getIndexByIdentifier(identifier);\r\n      stylesInDOM[index].references--;\r\n    }\r\n    var newLastIdentifiers = modulesToDom(newList, options);\r\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\r\n      var _identifier = lastIdentifiers[_i];\r\n      var _index = getIndexByIdentifier(_identifier);\r\n      if (stylesInDOM[_index].references === 0) {\r\n        stylesInDOM[_index].updater();\r\n        stylesInDOM.splice(_index, 1);\r\n      }\r\n    }\r\n    lastIdentifiers = newLastIdentifiers;\r\n  };\r\n};\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nvar memo = {};\r\n\r\n/* istanbul ignore next  */\r\nfunction getTarget(target) {\r\n  if (typeof memo[target] === \"undefined\") {\r\n    var styleTarget = document.querySelector(target);\r\n\r\n    // Special case to return head of iframe instead of iframe itself\r\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\r\n      try {\r\n        // This will throw an exception if access to iframe is blocked\r\n        // due to cross-origin restrictions\r\n        styleTarget = styleTarget.contentDocument.head;\r\n      } catch (e) {\r\n        // istanbul ignore next\r\n        styleTarget = null;\r\n      }\r\n    }\r\n    memo[target] = styleTarget;\r\n  }\r\n  return memo[target];\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction insertBySelector(insert, style) {\r\n  var target = getTarget(insert);\r\n  if (!target) {\r\n    throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\r\n  }\r\n  target.appendChild(style);\r\n}\r\nmodule.exports = insertBySelector;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/style-loader/dist/runtime/insertBySelector.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction insertStyleElement(options) {\r\n  var element = document.createElement(\"style\");\r\n  options.setAttributes(element, options.attributes);\r\n  options.insert(element, options.options);\r\n  return element;\r\n}\r\nmodule.exports = insertStyleElement;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/style-loader/dist/runtime/insertStyleElement.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction setAttributesWithoutAttributes(styleElement) {\r\n  var nonce =  true ? __webpack_require__.nc : 0;\r\n  if (nonce) {\r\n    styleElement.setAttribute(\"nonce\", nonce);\r\n  }\r\n}\r\nmodule.exports = setAttributesWithoutAttributes;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction apply(styleElement, options, obj) {\r\n  var css = \"\";\r\n  if (obj.supports) {\r\n    css += \"@supports (\".concat(obj.supports, \") {\");\r\n  }\r\n  if (obj.media) {\r\n    css += \"@media \".concat(obj.media, \" {\");\r\n  }\r\n  var needLayer = typeof obj.layer !== \"undefined\";\r\n  if (needLayer) {\r\n    css += \"@layer\".concat(obj.layer.length > 0 ? \" \".concat(obj.layer) : \"\", \" {\");\r\n  }\r\n  css += obj.css;\r\n  if (needLayer) {\r\n    css += \"}\";\r\n  }\r\n  if (obj.media) {\r\n    css += \"}\";\r\n  }\r\n  if (obj.supports) {\r\n    css += \"}\";\r\n  }\r\n  var sourceMap = obj.sourceMap;\r\n  if (sourceMap && typeof btoa !== \"undefined\") {\r\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\r\n  }\r\n\r\n  // For old IE\r\n  /* istanbul ignore if  */\r\n  options.styleTagTransform(css, styleElement, options.options);\r\n}\r\nfunction removeStyleElement(styleElement) {\r\n  // istanbul ignore if\r\n  if (styleElement.parentNode === null) {\r\n    return false;\r\n  }\r\n  styleElement.parentNode.removeChild(styleElement);\r\n}\r\n\r\n/* istanbul ignore next  */\r\nfunction domAPI(options) {\r\n  if (typeof document === \"undefined\") {\r\n    return {\r\n      update: function update() {},\r\n      remove: function remove() {}\r\n    };\r\n  }\r\n  var styleElement = options.insertStyleElement(options);\r\n  return {\r\n    update: function update(obj) {\r\n      apply(styleElement, options, obj);\r\n    },\r\n    remove: function remove() {\r\n      removeStyleElement(styleElement);\r\n    }\r\n  };\r\n}\r\nmodule.exports = domAPI;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/style-loader/dist/runtime/styleDomAPI.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\n/* istanbul ignore next  */\r\nfunction styleTagTransform(css, styleElement) {\r\n  if (styleElement.styleSheet) {\r\n    styleElement.styleSheet.cssText = css;\r\n  } else {\r\n    while (styleElement.firstChild) {\r\n      styleElement.removeChild(styleElement.firstChild);\r\n    }\r\n    styleElement.appendChild(document.createTextNode(css));\r\n  }\r\n}\r\nmodule.exports = styleTagTransform;\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/style-loader/dist/runtime/styleTagTransform.js?");

/***/ }),

/***/ "./src/bottleneck.js":
/*!***************************!*\
  !*** ./src/bottleneck.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   limiter: () => (/* binding */ limiter)\n/* harmony export */ });\n/* harmony import */ var bottleneck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bottleneck */ \"./node_modules/bottleneck/lib/index.js\");\n/* harmony import */ var bottleneck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bottleneck__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nconst limiter = new (bottleneck__WEBPACK_IMPORTED_MODULE_0___default())({\r\n    maxConcurrent: 1,\r\n    minTime: 250,\r\n});\r\n\n\n//# sourceURL=webpack://padlet-importing-script/./src/bottleneck.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   startImport: () => (/* binding */ startImport)\n/* harmony export */ });\n/* harmony import */ var _style_style_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style/style.scss */ \"./src/style/style.scss\");\n/* harmony import */ var _input_form_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./input-form.js */ \"./src/input-form.js\");\n/* harmony import */ var _media_imports_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./media-imports.js */ \"./src/media-imports.js\");\n/* harmony import */ var _bottleneck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bottleneck */ \"./src/bottleneck.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! papaparse */ \"./node_modules/papaparse/papaparse.min.js\");\n/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_4__);\n\r\n\r\n\r\n\r\n\r\n\r\nasync function startImport(api_key, board_id, data_files) {\r\n    try {\r\n        for (let file of data_files) {\r\n            papaparse__WEBPACK_IMPORTED_MODULE_4___default().parse(file, {\r\n                complete: (results) => {\r\n                    populateBoard(api_key, board_id, results);\r\n                },\r\n                header: true,\r\n            });\r\n        }\r\n    } catch (error) {\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * \r\n * @param {*} data - File object \r\n    {\r\n        data:   // array of parsed data\r\n        errors: // array of errors\r\n        meta:   // object with extra info\r\n    }\r\n */\r\nasync function populateBoard(api_key, board_id, data_file) {\r\n    let dataHeaders = data_file.meta.fields;\r\n    const sectionIDs = await gatherSections(api_key, board_id);\r\n\r\n    dataHeaders = dataHeaders.filter((header) => {\r\n        return sectionIDs.has(header);\r\n    });\r\n\r\n    // progress tracker\r\n    const processCount = data_file.data.length * dataHeaders.length;\r\n    let currentCount = 0;\r\n\r\n    for (let entry of data_file.data) {\r\n        for (let header of dataHeaders) {\r\n            const sectionID = sectionIDs.get(header);\r\n            const post = createPostJSON(entry[header], sectionID);\r\n\r\n            await _bottleneck__WEBPACK_IMPORTED_MODULE_3__.limiter.schedule(() => {\r\n                currentCount++;\r\n                const progress = currentCount / processCount;\r\n                return Promise.all([insertPost(api_key, board_id, post)]);\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nfunction createPostJSON(body, sectionID) {\r\n    return {\r\n        data: {\r\n            type: 'post',\r\n            attributes: {\r\n                content: {\r\n                    body,\r\n                },\r\n            },\r\n            relationships: {\r\n                section: {\r\n                    data: {\r\n                        id: sectionID,\r\n                    },\r\n                },\r\n            },\r\n        },\r\n    };\r\n}\r\n\r\nasync function getBoard(api_key, board_id) {\r\n    try {\r\n        const board = await fetch(\r\n            `https://api.padlet.dev/v1/boards/${board_id}?include=posts,sections`,\r\n            {\r\n                headers: {\r\n                    'X-Api-Key': api_key,\r\n                    accept: 'application/vnd.api+json',\r\n                },\r\n            }\r\n        );\r\n\r\n        return board;\r\n    } catch (error) {\r\n        throw error;\r\n    }\r\n}\r\n\r\nasync function insertPost(API, boardID, post) {\r\n    try {\r\n        fetch(`https://api.padlet.dev/v1/boards/${boardID}/posts`, {\r\n            method: 'POST',\r\n            headers: {\r\n                'X-Api-Key': API,\r\n                accept: 'application/vnd.api+json',\r\n                'content-type': 'application/vnd.api+json',\r\n            },\r\n            body: JSON.stringify(post),\r\n        });\r\n    } catch (error) {\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * Create a Map and store Board Section titles and IDs.\r\n * Map {title<string>: id<string>}\r\n * @param {*} API\r\n * @param {*} boardID\r\n * @returns\r\n */\r\nasync function gatherSections(API, boardID) {\r\n    try {\r\n        const boardData = await getBoard(API, boardID)\r\n            .then((response) => response.text())\r\n            .then((result) => JSON.parse(result));\r\n        const included = boardData.included;\r\n        const sections = new Map();\r\n\r\n        for (let obj of included) {\r\n            if (obj.type !== 'section') {\r\n                continue;\r\n            }\r\n\r\n            const title = obj.attributes.title;\r\n            const id = obj.id;\r\n\r\n            sections.set(title, id);\r\n        }\r\n\r\n        return sections;\r\n    } catch (error) {\r\n        throw error;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://padlet-importing-script/./src/index.js?");

/***/ }),

/***/ "./src/input-form.js":
/*!***************************!*\
  !*** ./src/input-form.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"./src/index.js\");\n\r\n\r\nconst button = document.getElementById('import');\r\nconst api_key = document.getElementById('api_key');\r\nconst board_id = document.getElementById('board_id');\r\nconst dropZone = document.getElementById('drop_zone');\r\nconst data_file = document.getElementById('data_file');\r\nconst form = document.querySelector('form');\r\n\r\nconst disclaimerLink = document.getElementById('disclaimer');\r\nconst disclaimerPop = document.querySelector('.pop.disclaimer');\r\nconst clickBackdrops = document.querySelectorAll('.click-backdrop');\r\nconst instructionsLink = document.getElementById('instructions');\r\nconst instructionsPop = document.querySelector('.pop.instructions');\r\nconst closers = document.querySelectorAll('button.closer');\r\n\r\n(() => {\r\n    disclaimerLink.addEventListener('click', () => {\r\n        disclaimerPop.classList.remove('hidden');\r\n        disableBodyScroll();\r\n    });\r\n\r\n    instructionsLink.addEventListener('click', () => {\r\n        instructionsPop.classList.remove('hidden');\r\n        disableBodyScroll();\r\n    });\r\n\r\n    clickBackdrops.forEach((backdrop) => {\r\n        backdrop.addEventListener('click', (e) => {\r\n            if (e.target.classList.contains('click-backdrop')) {\r\n                backdrop.classList.add('hidden');\r\n            }\r\n\r\n            disableBodyScroll(false);\r\n        });\r\n    });\r\n\r\n    closers.forEach((closer) => {\r\n        closer.addEventListener('click', (e) => {\r\n            const popper = e.target.parentElement.parentElement;\r\n            popper.classList.add('hidden');\r\n        });\r\n    });\r\n})();\r\n\r\nfunction disableBodyScroll(disable = true) {\r\n    const body = document.querySelector('body');\r\n\r\n    if (disable) {\r\n        body.classList.add('no-scroll');\r\n    } else {\r\n        body.classList.remove('no-scroll');\r\n    }\r\n}\r\n\r\nbutton.addEventListener('click', async (e) => {\r\n    const API_KEY = api_key.value;\r\n    const BOARD_ID = board_id.value;\r\n    const dataFiles = data_file.files;\r\n\r\n    try {\r\n        if (!form.reportValidity()) {\r\n            throw new Error('Form is incomplete.');\r\n        }\r\n\r\n        if (!validateFileType(dataFiles)) {\r\n            data_file.value = '';\r\n            throw new Error('Invalid file type.');\r\n        }\r\n\r\n        await (0,_index_js__WEBPACK_IMPORTED_MODULE_0__.startImport)(API_KEY, BOARD_ID, dataFiles);\r\n    } catch (error) {\r\n        console.error(error);\r\n    }\r\n});\r\n\r\nfunction validateFileType(files) {\r\n    const validTypes = new Set(['csv']);\r\n\r\n    for (let file of files) {\r\n        const fileName = file.name;\r\n        const fileType = fileName.split('.')[1];\r\n\r\n        if (validTypes.has(fileType)) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\n\n//# sourceURL=webpack://padlet-importing-script/./src/input-form.js?");

/***/ }),

/***/ "./src/media-imports.js":
/*!******************************!*\
  !*** ./src/media-imports.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _style_logo_Crane_svg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style/logo/Crane.svg */ \"./src/style/logo/Crane.svg\");\n\r\n\r\nconst logoElements = document.querySelectorAll('img.padlet_logo');\r\n\r\nlogoElements.forEach((element) => {\r\n    element.src = _style_logo_Crane_svg__WEBPACK_IMPORTED_MODULE_0__;\r\n    element.alt = 'Padlet Logo';\r\n    element.title = 'Padlet Logo';\r\n});\r\n\n\n//# sourceURL=webpack://padlet-importing-script/./src/media-imports.js?");

/***/ }),

/***/ "./src/style/font/Hind/Hind-Regular.ttf":
/*!**********************************************!*\
  !*** ./src/style/font/Hind/Hind-Regular.ttf ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"4d32dabf118c5c7e3f48.ttf\";\n\n//# sourceURL=webpack://padlet-importing-script/./src/style/font/Hind/Hind-Regular.ttf?");

/***/ }),

/***/ "./src/style/font/Montserrat/Montserrat-VariableFont_wght.ttf":
/*!********************************************************************!*\
  !*** ./src/style/font/Montserrat/Montserrat-VariableFont_wght.ttf ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"7e687123cd4528224ce5.ttf\";\n\n//# sourceURL=webpack://padlet-importing-script/./src/style/font/Montserrat/Montserrat-VariableFont_wght.ttf?");

/***/ }),

/***/ "./src/style/logo/Crane.svg":
/*!**********************************!*\
  !*** ./src/style/logo/Crane.svg ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("module.exports = __webpack_require__.p + \"17c91dd650de9a1db34d.svg\";\n\n//# sourceURL=webpack://padlet-importing-script/./src/style/logo/Crane.svg?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/lua.json":
/*!**********************************************!*\
  !*** ./node_modules/bottleneck/lib/lua.json ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"blacklist_client.lua\":\"local blacklist = ARGV[num_static_argv + 1]\\\\n\\\\nif redis.call(\\'zscore\\', client_last_seen_key, blacklist) then\\\\n  redis.call(\\'zadd\\', client_last_seen_key, 0, blacklist)\\\\nend\\\\n\\\\n\\\\nreturn {}\\\\n\",\"check.lua\":\"local weight = tonumber(ARGV[num_static_argv + 1])\\\\n\\\\nlocal capacity = process_tick(now, false)[\\'capacity\\']\\\\nlocal nextRequest = tonumber(redis.call(\\'hget\\', settings_key, \\'nextRequest\\'))\\\\n\\\\nreturn conditions_check(capacity, weight) and nextRequest - now <= 0\\\\n\",\"conditions_check.lua\":\"local conditions_check = function (capacity, weight)\\\\n  return capacity == nil or weight <= capacity\\\\nend\\\\n\",\"current_reservoir.lua\":\"return process_tick(now, false)[\\'reservoir\\']\\\\n\",\"done.lua\":\"process_tick(now, false)\\\\n\\\\nreturn tonumber(redis.call(\\'hget\\', settings_key, \\'done\\'))\\\\n\",\"free.lua\":\"local index = ARGV[num_static_argv + 1]\\\\n\\\\nredis.call(\\'zadd\\', job_expirations_key, 0, index)\\\\n\\\\nreturn process_tick(now, false)[\\'running\\']\\\\n\",\"get_time.lua\":\"redis.replicate_commands()\\\\n\\\\nlocal get_time = function ()\\\\n  local time = redis.call(\\'time\\')\\\\n\\\\n  return tonumber(time[1]..string.sub(time[2], 1, 3))\\\\nend\\\\n\",\"group_check.lua\":\"return not (redis.call(\\'exists\\', settings_key) == 1)\\\\n\",\"heartbeat.lua\":\"process_tick(now, true)\\\\n\",\"increment_reservoir.lua\":\"local incr = tonumber(ARGV[num_static_argv + 1])\\\\n\\\\nredis.call(\\'hincrby\\', settings_key, \\'reservoir\\', incr)\\\\n\\\\nlocal reservoir = process_tick(now, true)[\\'reservoir\\']\\\\n\\\\nlocal groupTimeout = tonumber(redis.call(\\'hget\\', settings_key, \\'groupTimeout\\'))\\\\nrefresh_expiration(0, 0, groupTimeout)\\\\n\\\\nreturn reservoir\\\\n\",\"init.lua\":\"local clear = tonumber(ARGV[num_static_argv + 1])\\\\nlocal limiter_version = ARGV[num_static_argv + 2]\\\\nlocal num_local_argv = num_static_argv + 2\\\\n\\\\nif clear == 1 then\\\\n  redis.call(\\'del\\', unpack(KEYS))\\\\nend\\\\n\\\\nif redis.call(\\'exists\\', settings_key) == 0 then\\\\n  -- Create\\\\n  local args = {\\'hmset\\', settings_key}\\\\n\\\\n  for i = num_local_argv + 1, #ARGV do\\\\n    table.insert(args, ARGV[i])\\\\n  end\\\\n\\\\n  redis.call(unpack(args))\\\\n  redis.call(\\'hmset\\', settings_key,\\\\n    \\'nextRequest\\', now,\\\\n    \\'lastReservoirRefresh\\', now,\\\\n    \\'lastReservoirIncrease\\', now,\\\\n    \\'running\\', 0,\\\\n    \\'done\\', 0,\\\\n    \\'unblockTime\\', 0,\\\\n    \\'capacityPriorityCounter\\', 0\\\\n  )\\\\n\\\\nelse\\\\n  -- Apply migrations\\\\n  local settings = redis.call(\\'hmget\\', settings_key,\\\\n    \\'id\\',\\\\n    \\'version\\'\\\\n  )\\\\n  local id = settings[1]\\\\n  local current_version = settings[2]\\\\n\\\\n  if current_version ~= limiter_version then\\\\n    local version_digits = {}\\\\n    for k, v in string.gmatch(current_version, \\\\\"([^.]+)\\\\\") do\\\\n      table.insert(version_digits, tonumber(k))\\\\n    end\\\\n\\\\n    -- 2.10.0\\\\n    if version_digits[2] < 10 then\\\\n      redis.call(\\'hsetnx\\', settings_key, \\'reservoirRefreshInterval\\', \\'\\')\\\\n      redis.call(\\'hsetnx\\', settings_key, \\'reservoirRefreshAmount\\', \\'\\')\\\\n      redis.call(\\'hsetnx\\', settings_key, \\'lastReservoirRefresh\\', \\'\\')\\\\n      redis.call(\\'hsetnx\\', settings_key, \\'done\\', 0)\\\\n      redis.call(\\'hset\\', settings_key, \\'version\\', \\'2.10.0\\')\\\\n    end\\\\n\\\\n    -- 2.11.1\\\\n    if version_digits[2] < 11 or (version_digits[2] == 11 and version_digits[3] < 1) then\\\\n      if redis.call(\\'hstrlen\\', settings_key, \\'lastReservoirRefresh\\') == 0 then\\\\n        redis.call(\\'hmset\\', settings_key,\\\\n          \\'lastReservoirRefresh\\', now,\\\\n          \\'version\\', \\'2.11.1\\'\\\\n        )\\\\n      end\\\\n    end\\\\n\\\\n    -- 2.14.0\\\\n    if version_digits[2] < 14 then\\\\n      local old_running_key = \\'b_\\'..id..\\'_running\\'\\\\n      local old_executing_key = \\'b_\\'..id..\\'_executing\\'\\\\n\\\\n      if redis.call(\\'exists\\', old_running_key) == 1 then\\\\n        redis.call(\\'rename\\', old_running_key, job_weights_key)\\\\n      end\\\\n      if redis.call(\\'exists\\', old_executing_key) == 1 then\\\\n        redis.call(\\'rename\\', old_executing_key, job_expirations_key)\\\\n      end\\\\n      redis.call(\\'hset\\', settings_key, \\'version\\', \\'2.14.0\\')\\\\n    end\\\\n\\\\n    -- 2.15.2\\\\n    if version_digits[2] < 15 or (version_digits[2] == 15 and version_digits[3] < 2) then\\\\n      redis.call(\\'hsetnx\\', settings_key, \\'capacityPriorityCounter\\', 0)\\\\n      redis.call(\\'hset\\', settings_key, \\'version\\', \\'2.15.2\\')\\\\n    end\\\\n\\\\n    -- 2.17.0\\\\n    if version_digits[2] < 17 then\\\\n      redis.call(\\'hsetnx\\', settings_key, \\'clientTimeout\\', 10000)\\\\n      redis.call(\\'hset\\', settings_key, \\'version\\', \\'2.17.0\\')\\\\n    end\\\\n\\\\n    -- 2.18.0\\\\n    if version_digits[2] < 18 then\\\\n      redis.call(\\'hsetnx\\', settings_key, \\'reservoirIncreaseInterval\\', \\'\\')\\\\n      redis.call(\\'hsetnx\\', settings_key, \\'reservoirIncreaseAmount\\', \\'\\')\\\\n      redis.call(\\'hsetnx\\', settings_key, \\'reservoirIncreaseMaximum\\', \\'\\')\\\\n      redis.call(\\'hsetnx\\', settings_key, \\'lastReservoirIncrease\\', now)\\\\n      redis.call(\\'hset\\', settings_key, \\'version\\', \\'2.18.0\\')\\\\n    end\\\\n\\\\n  end\\\\n\\\\n  process_tick(now, false)\\\\nend\\\\n\\\\nlocal groupTimeout = tonumber(redis.call(\\'hget\\', settings_key, \\'groupTimeout\\'))\\\\nrefresh_expiration(0, 0, groupTimeout)\\\\n\\\\nreturn {}\\\\n\",\"process_tick.lua\":\"local process_tick = function (now, always_publish)\\\\n\\\\n  local compute_capacity = function (maxConcurrent, running, reservoir)\\\\n    if maxConcurrent ~= nil and reservoir ~= nil then\\\\n      return math.min((maxConcurrent - running), reservoir)\\\\n    elseif maxConcurrent ~= nil then\\\\n      return maxConcurrent - running\\\\n    elseif reservoir ~= nil then\\\\n      return reservoir\\\\n    else\\\\n      return nil\\\\n    end\\\\n  end\\\\n\\\\n  local settings = redis.call(\\'hmget\\', settings_key,\\\\n    \\'id\\',\\\\n    \\'maxConcurrent\\',\\\\n    \\'running\\',\\\\n    \\'reservoir\\',\\\\n    \\'reservoirRefreshInterval\\',\\\\n    \\'reservoirRefreshAmount\\',\\\\n    \\'lastReservoirRefresh\\',\\\\n    \\'reservoirIncreaseInterval\\',\\\\n    \\'reservoirIncreaseAmount\\',\\\\n    \\'reservoirIncreaseMaximum\\',\\\\n    \\'lastReservoirIncrease\\',\\\\n    \\'capacityPriorityCounter\\',\\\\n    \\'clientTimeout\\'\\\\n  )\\\\n  local id = settings[1]\\\\n  local maxConcurrent = tonumber(settings[2])\\\\n  local running = tonumber(settings[3])\\\\n  local reservoir = tonumber(settings[4])\\\\n  local reservoirRefreshInterval = tonumber(settings[5])\\\\n  local reservoirRefreshAmount = tonumber(settings[6])\\\\n  local lastReservoirRefresh = tonumber(settings[7])\\\\n  local reservoirIncreaseInterval = tonumber(settings[8])\\\\n  local reservoirIncreaseAmount = tonumber(settings[9])\\\\n  local reservoirIncreaseMaximum = tonumber(settings[10])\\\\n  local lastReservoirIncrease = tonumber(settings[11])\\\\n  local capacityPriorityCounter = tonumber(settings[12])\\\\n  local clientTimeout = tonumber(settings[13])\\\\n\\\\n  local initial_capacity = compute_capacity(maxConcurrent, running, reservoir)\\\\n\\\\n  --\\\\n  -- Process \\'running\\' changes\\\\n  --\\\\n  local expired = redis.call(\\'zrangebyscore\\', job_expirations_key, \\'-inf\\', \\'(\\'..now)\\\\n\\\\n  if #expired > 0 then\\\\n    redis.call(\\'zremrangebyscore\\', job_expirations_key, \\'-inf\\', \\'(\\'..now)\\\\n\\\\n    local flush_batch = function (batch, acc)\\\\n      local weights = redis.call(\\'hmget\\', job_weights_key, unpack(batch))\\\\n                      redis.call(\\'hdel\\',  job_weights_key, unpack(batch))\\\\n      local clients = redis.call(\\'hmget\\', job_clients_key, unpack(batch))\\\\n                      redis.call(\\'hdel\\',  job_clients_key, unpack(batch))\\\\n\\\\n      -- Calculate sum of removed weights\\\\n      for i = 1, #weights do\\\\n        acc[\\'total\\'] = acc[\\'total\\'] + (tonumber(weights[i]) or 0)\\\\n      end\\\\n\\\\n      -- Calculate sum of removed weights by client\\\\n      local client_weights = {}\\\\n      for i = 1, #clients do\\\\n        local removed = tonumber(weights[i]) or 0\\\\n        if removed > 0 then\\\\n          acc[\\'client_weights\\'][clients[i]] = (acc[\\'client_weights\\'][clients[i]] or 0) + removed\\\\n        end\\\\n      end\\\\n    end\\\\n\\\\n    local acc = {\\\\n      [\\'total\\'] = 0,\\\\n      [\\'client_weights\\'] = {}\\\\n    }\\\\n    local batch_size = 1000\\\\n\\\\n    -- Compute changes to Zsets and apply changes to Hashes\\\\n    for i = 1, #expired, batch_size do\\\\n      local batch = {}\\\\n      for j = i, math.min(i + batch_size - 1, #expired) do\\\\n        table.insert(batch, expired[j])\\\\n      end\\\\n\\\\n      flush_batch(batch, acc)\\\\n    end\\\\n\\\\n    -- Apply changes to Zsets\\\\n    if acc[\\'total\\'] > 0 then\\\\n      redis.call(\\'hincrby\\', settings_key, \\'done\\', acc[\\'total\\'])\\\\n      running = tonumber(redis.call(\\'hincrby\\', settings_key, \\'running\\', -acc[\\'total\\']))\\\\n    end\\\\n\\\\n    for client, weight in pairs(acc[\\'client_weights\\']) do\\\\n      redis.call(\\'zincrby\\', client_running_key, -weight, client)\\\\n    end\\\\n  end\\\\n\\\\n  --\\\\n  -- Process \\'reservoir\\' changes\\\\n  --\\\\n  local reservoirRefreshActive = reservoirRefreshInterval ~= nil and reservoirRefreshAmount ~= nil\\\\n  if reservoirRefreshActive and now >= lastReservoirRefresh + reservoirRefreshInterval then\\\\n    reservoir = reservoirRefreshAmount\\\\n    redis.call(\\'hmset\\', settings_key,\\\\n      \\'reservoir\\', reservoir,\\\\n      \\'lastReservoirRefresh\\', now\\\\n    )\\\\n  end\\\\n\\\\n  local reservoirIncreaseActive = reservoirIncreaseInterval ~= nil and reservoirIncreaseAmount ~= nil\\\\n  if reservoirIncreaseActive and now >= lastReservoirIncrease + reservoirIncreaseInterval then\\\\n    local num_intervals = math.floor((now - lastReservoirIncrease) / reservoirIncreaseInterval)\\\\n    local incr = reservoirIncreaseAmount * num_intervals\\\\n    if reservoirIncreaseMaximum ~= nil then\\\\n      incr = math.min(incr, reservoirIncreaseMaximum - (reservoir or 0))\\\\n    end\\\\n    if incr > 0 then\\\\n      reservoir = (reservoir or 0) + incr\\\\n    end\\\\n    redis.call(\\'hmset\\', settings_key,\\\\n      \\'reservoir\\', reservoir,\\\\n      \\'lastReservoirIncrease\\', lastReservoirIncrease + (num_intervals * reservoirIncreaseInterval)\\\\n    )\\\\n  end\\\\n\\\\n  --\\\\n  -- Clear unresponsive clients\\\\n  --\\\\n  local unresponsive = redis.call(\\'zrangebyscore\\', client_last_seen_key, \\'-inf\\', (now - clientTimeout))\\\\n  local unresponsive_lookup = {}\\\\n  local terminated_clients = {}\\\\n  for i = 1, #unresponsive do\\\\n    unresponsive_lookup[unresponsive[i]] = true\\\\n    if tonumber(redis.call(\\'zscore\\', client_running_key, unresponsive[i])) == 0 then\\\\n      table.insert(terminated_clients, unresponsive[i])\\\\n    end\\\\n  end\\\\n  if #terminated_clients > 0 then\\\\n    redis.call(\\'zrem\\', client_running_key,         unpack(terminated_clients))\\\\n    redis.call(\\'hdel\\', client_num_queued_key,      unpack(terminated_clients))\\\\n    redis.call(\\'zrem\\', client_last_registered_key, unpack(terminated_clients))\\\\n    redis.call(\\'zrem\\', client_last_seen_key,       unpack(terminated_clients))\\\\n  end\\\\n\\\\n  --\\\\n  -- Broadcast capacity changes\\\\n  --\\\\n  local final_capacity = compute_capacity(maxConcurrent, running, reservoir)\\\\n\\\\n  if always_publish or (initial_capacity ~= nil and final_capacity == nil) then\\\\n    -- always_publish or was not unlimited, now unlimited\\\\n    redis.call(\\'publish\\', \\'b_\\'..id, \\'capacity:\\'..(final_capacity or \\'\\'))\\\\n\\\\n  elseif initial_capacity ~= nil and final_capacity ~= nil and final_capacity > initial_capacity then\\\\n    -- capacity was increased\\\\n    -- send the capacity message to the limiter having the lowest number of running jobs\\\\n    -- the tiebreaker is the limiter having not registered a job in the longest time\\\\n\\\\n    local lowest_concurrency_value = nil\\\\n    local lowest_concurrency_clients = {}\\\\n    local lowest_concurrency_last_registered = {}\\\\n    local client_concurrencies = redis.call(\\'zrange\\', client_running_key, 0, -1, \\'withscores\\')\\\\n\\\\n    for i = 1, #client_concurrencies, 2 do\\\\n      local client = client_concurrencies[i]\\\\n      local concurrency = tonumber(client_concurrencies[i+1])\\\\n\\\\n      if (\\\\n        lowest_concurrency_value == nil or lowest_concurrency_value == concurrency\\\\n      ) and (\\\\n        not unresponsive_lookup[client]\\\\n      ) and (\\\\n        tonumber(redis.call(\\'hget\\', client_num_queued_key, client)) > 0\\\\n      ) then\\\\n        lowest_concurrency_value = concurrency\\\\n        table.insert(lowest_concurrency_clients, client)\\\\n        local last_registered = tonumber(redis.call(\\'zscore\\', client_last_registered_key, client))\\\\n        table.insert(lowest_concurrency_last_registered, last_registered)\\\\n      end\\\\n    end\\\\n\\\\n    if #lowest_concurrency_clients > 0 then\\\\n      local position = 1\\\\n      local earliest = lowest_concurrency_last_registered[1]\\\\n\\\\n      for i,v in ipairs(lowest_concurrency_last_registered) do\\\\n        if v < earliest then\\\\n          position = i\\\\n          earliest = v\\\\n        end\\\\n      end\\\\n\\\\n      local next_client = lowest_concurrency_clients[position]\\\\n      redis.call(\\'publish\\', \\'b_\\'..id,\\\\n        \\'capacity-priority:\\'..(final_capacity or \\'\\')..\\\\n        \\':\\'..next_client..\\\\n        \\':\\'..capacityPriorityCounter\\\\n      )\\\\n      redis.call(\\'hincrby\\', settings_key, \\'capacityPriorityCounter\\', \\'1\\')\\\\n    else\\\\n      redis.call(\\'publish\\', \\'b_\\'..id, \\'capacity:\\'..(final_capacity or \\'\\'))\\\\n    end\\\\n  end\\\\n\\\\n  return {\\\\n    [\\'capacity\\'] = final_capacity,\\\\n    [\\'running\\'] = running,\\\\n    [\\'reservoir\\'] = reservoir\\\\n  }\\\\nend\\\\n\",\"queued.lua\":\"local clientTimeout = tonumber(redis.call(\\'hget\\', settings_key, \\'clientTimeout\\'))\\\\nlocal valid_clients = redis.call(\\'zrangebyscore\\', client_last_seen_key, (now - clientTimeout), \\'inf\\')\\\\nlocal client_queued = redis.call(\\'hmget\\', client_num_queued_key, unpack(valid_clients))\\\\n\\\\nlocal sum = 0\\\\nfor i = 1, #client_queued do\\\\n  sum = sum + tonumber(client_queued[i])\\\\nend\\\\n\\\\nreturn sum\\\\n\",\"refresh_expiration.lua\":\"local refresh_expiration = function (now, nextRequest, groupTimeout)\\\\n\\\\n  if groupTimeout ~= nil then\\\\n    local ttl = (nextRequest + groupTimeout) - now\\\\n\\\\n    for i = 1, #KEYS do\\\\n      redis.call(\\'pexpire\\', KEYS[i], ttl)\\\\n    end\\\\n  end\\\\n\\\\nend\\\\n\",\"refs.lua\":\"local settings_key = KEYS[1]\\\\nlocal job_weights_key = KEYS[2]\\\\nlocal job_expirations_key = KEYS[3]\\\\nlocal job_clients_key = KEYS[4]\\\\nlocal client_running_key = KEYS[5]\\\\nlocal client_num_queued_key = KEYS[6]\\\\nlocal client_last_registered_key = KEYS[7]\\\\nlocal client_last_seen_key = KEYS[8]\\\\n\\\\nlocal now = tonumber(ARGV[1])\\\\nlocal client = ARGV[2]\\\\n\\\\nlocal num_static_argv = 2\\\\n\",\"register.lua\":\"local index = ARGV[num_static_argv + 1]\\\\nlocal weight = tonumber(ARGV[num_static_argv + 2])\\\\nlocal expiration = tonumber(ARGV[num_static_argv + 3])\\\\n\\\\nlocal state = process_tick(now, false)\\\\nlocal capacity = state[\\'capacity\\']\\\\nlocal reservoir = state[\\'reservoir\\']\\\\n\\\\nlocal settings = redis.call(\\'hmget\\', settings_key,\\\\n  \\'nextRequest\\',\\\\n  \\'minTime\\',\\\\n  \\'groupTimeout\\'\\\\n)\\\\nlocal nextRequest = tonumber(settings[1])\\\\nlocal minTime = tonumber(settings[2])\\\\nlocal groupTimeout = tonumber(settings[3])\\\\n\\\\nif conditions_check(capacity, weight) then\\\\n\\\\n  redis.call(\\'hincrby\\', settings_key, \\'running\\', weight)\\\\n  redis.call(\\'hset\\', job_weights_key, index, weight)\\\\n  if expiration ~= nil then\\\\n    redis.call(\\'zadd\\', job_expirations_key, now + expiration, index)\\\\n  end\\\\n  redis.call(\\'hset\\', job_clients_key, index, client)\\\\n  redis.call(\\'zincrby\\', client_running_key, weight, client)\\\\n  redis.call(\\'hincrby\\', client_num_queued_key, client, -1)\\\\n  redis.call(\\'zadd\\', client_last_registered_key, now, client)\\\\n\\\\n  local wait = math.max(nextRequest - now, 0)\\\\n  local newNextRequest = now + wait + minTime\\\\n\\\\n  if reservoir == nil then\\\\n    redis.call(\\'hset\\', settings_key,\\\\n      \\'nextRequest\\', newNextRequest\\\\n    )\\\\n  else\\\\n    reservoir = reservoir - weight\\\\n    redis.call(\\'hmset\\', settings_key,\\\\n      \\'reservoir\\', reservoir,\\\\n      \\'nextRequest\\', newNextRequest\\\\n    )\\\\n  end\\\\n\\\\n  refresh_expiration(now, newNextRequest, groupTimeout)\\\\n\\\\n  return {true, wait, reservoir}\\\\n\\\\nelse\\\\n  return {false}\\\\nend\\\\n\",\"register_client.lua\":\"local queued = tonumber(ARGV[num_static_argv + 1])\\\\n\\\\n-- Could have been re-registered concurrently\\\\nif not redis.call(\\'zscore\\', client_last_seen_key, client) then\\\\n  redis.call(\\'zadd\\', client_running_key, 0, client)\\\\n  redis.call(\\'hset\\', client_num_queued_key, client, queued)\\\\n  redis.call(\\'zadd\\', client_last_registered_key, 0, client)\\\\nend\\\\n\\\\nredis.call(\\'zadd\\', client_last_seen_key, now, client)\\\\n\\\\nreturn {}\\\\n\",\"running.lua\":\"return process_tick(now, false)[\\'running\\']\\\\n\",\"submit.lua\":\"local queueLength = tonumber(ARGV[num_static_argv + 1])\\\\nlocal weight = tonumber(ARGV[num_static_argv + 2])\\\\n\\\\nlocal capacity = process_tick(now, false)[\\'capacity\\']\\\\n\\\\nlocal settings = redis.call(\\'hmget\\', settings_key,\\\\n  \\'id\\',\\\\n  \\'maxConcurrent\\',\\\\n  \\'highWater\\',\\\\n  \\'nextRequest\\',\\\\n  \\'strategy\\',\\\\n  \\'unblockTime\\',\\\\n  \\'penalty\\',\\\\n  \\'minTime\\',\\\\n  \\'groupTimeout\\'\\\\n)\\\\nlocal id = settings[1]\\\\nlocal maxConcurrent = tonumber(settings[2])\\\\nlocal highWater = tonumber(settings[3])\\\\nlocal nextRequest = tonumber(settings[4])\\\\nlocal strategy = tonumber(settings[5])\\\\nlocal unblockTime = tonumber(settings[6])\\\\nlocal penalty = tonumber(settings[7])\\\\nlocal minTime = tonumber(settings[8])\\\\nlocal groupTimeout = tonumber(settings[9])\\\\n\\\\nif maxConcurrent ~= nil and weight > maxConcurrent then\\\\n  return redis.error_reply(\\'OVERWEIGHT:\\'..weight..\\':\\'..maxConcurrent)\\\\nend\\\\n\\\\nlocal reachedHWM = (highWater ~= nil and queueLength == highWater\\\\n  and not (\\\\n    conditions_check(capacity, weight)\\\\n    and nextRequest - now <= 0\\\\n  )\\\\n)\\\\n\\\\nlocal blocked = strategy == 3 and (reachedHWM or unblockTime >= now)\\\\n\\\\nif blocked then\\\\n  local computedPenalty = penalty\\\\n  if computedPenalty == nil then\\\\n    if minTime == 0 then\\\\n      computedPenalty = 5000\\\\n    else\\\\n      computedPenalty = 15 * minTime\\\\n    end\\\\n  end\\\\n\\\\n  local newNextRequest = now + computedPenalty + minTime\\\\n\\\\n  redis.call(\\'hmset\\', settings_key,\\\\n    \\'unblockTime\\', now + computedPenalty,\\\\n    \\'nextRequest\\', newNextRequest\\\\n  )\\\\n\\\\n  local clients_queued_reset = redis.call(\\'hkeys\\', client_num_queued_key)\\\\n  local queued_reset = {}\\\\n  for i = 1, #clients_queued_reset do\\\\n    table.insert(queued_reset, clients_queued_reset[i])\\\\n    table.insert(queued_reset, 0)\\\\n  end\\\\n  redis.call(\\'hmset\\', client_num_queued_key, unpack(queued_reset))\\\\n\\\\n  redis.call(\\'publish\\', \\'b_\\'..id, \\'blocked:\\')\\\\n\\\\n  refresh_expiration(now, newNextRequest, groupTimeout)\\\\nend\\\\n\\\\nif not blocked and not reachedHWM then\\\\n  redis.call(\\'hincrby\\', client_num_queued_key, client, 1)\\\\nend\\\\n\\\\nreturn {reachedHWM, blocked, strategy}\\\\n\",\"update_settings.lua\":\"local args = {\\'hmset\\', settings_key}\\\\n\\\\nfor i = num_static_argv + 1, #ARGV do\\\\n  table.insert(args, ARGV[i])\\\\nend\\\\n\\\\nredis.call(unpack(args))\\\\n\\\\nprocess_tick(now, true)\\\\n\\\\nlocal groupTimeout = tonumber(redis.call(\\'hget\\', settings_key, \\'groupTimeout\\'))\\\\nrefresh_expiration(0, 0, groupTimeout)\\\\n\\\\nreturn {}\\\\n\",\"validate_client.lua\":\"if not redis.call(\\'zscore\\', client_last_seen_key, client) then\\\\n  return redis.error_reply(\\'UNKNOWN_CLIENT\\')\\\\nend\\\\n\\\\nredis.call(\\'zadd\\', client_last_seen_key, now, client)\\\\n\",\"validate_keys.lua\":\"if not (redis.call(\\'exists\\', settings_key) == 1) then\\\\n  return redis.error_reply(\\'SETTINGS_KEY_NOT_FOUND\\')\\\\nend\\\\n\"}');\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/lua.json?");

/***/ }),

/***/ "./node_modules/bottleneck/lib/version.json":
/*!**************************************************!*\
  !*** ./node_modules/bottleneck/lib/version.json ***!
  \**************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = {\"version\":\"2.19.5\"};\n\n//# sourceURL=webpack://padlet-importing-script/./node_modules/bottleneck/lib/version.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;